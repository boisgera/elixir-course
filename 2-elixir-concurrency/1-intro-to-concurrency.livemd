<!-- livebook:{"file_entries":[{"name":"pids-parent-child.png","type":"attachment"},{"name":"spawn-3.png","type":"attachment"}]} -->

# C2N1 ‚Äì Processus et programmation concurrente

```elixir
Mix.install([
  {:kino, "~> 0.16.1"},
])

defmodule TP do
  def trace(trace_target \\ :all, trace_function) do
    Kino.Process.render_seq_trace(
      trace_target,
      trace_function,
      message_label: fn msg ->
        case msg do
          msg when is_binary(msg) -> {:ok, "MSG: #{msg}"}
          {pid, msg} when is_pid(pid) and is_binary(msg) -> {:ok, "MSG: #{msg}"}
          {pid, msg} when is_pid(pid) and is_atom(msg) -> {:ok, "MSG: #{inspect(msg)}"}
          {:result, _, value} -> {:ok, "RES: #{value}"}  
          _ -> :continue
        end
      end
    )
  end
end
```

## Objectifs de la s√©ance

* Comprendre ce qu‚Äôest un **processus Elixir** (vs thread OS) et pourquoi ils sont si l√©gers.
* Savoir **cr√©er** un processus (`spawn/1`).
* **Communiquer** entre processus (`send`/`receive`, bo√Ætes aux lettres, timeouts).

## BEAM, isolation et tol√©rance aux pannes

Vous avez peut-√™tre d√©j√† enetendu le terme "processus" en parlant de l'ex√©cution de programmes sur votre ordinateur ?

De fa√ßon g√©n√©rales, les prgrammes informatiques s'ex√©cutent _en parall√®le_, dans des environnement _isol√©s_: ils se partagent la puissance de calcul et la m√©moire, sans se "bloquer" les uns les autres ou "√©craser" zones de m√©moires qu'ils utilisent les uns les autres.

Au sein d'un programme Elixir, diff√©rents **processus** ("process") s'ex√©cutent √©galement en parall√®le. Ces processus sont diff√©rents des process habituels g√©r√©s par le syst√®me d'exploitation: ici c'est la VM BEAM ‚Äì l'environnement d'ex√©cution h√©rit√© d'Erlang ‚Äì qui la g√©rer et coordonner ces processus au sein de notre programme. Cette couche d'abstraction suppl√©mentaire a un certain nombre d'avantages:

* contrairement aux processus syst√®mes qui sont relativement co√ªteux en ressources, les process BEAM sont extr√™mement l√©gers: il n'est pas rare qu'un syst√®me Erlang/Elixir lance des millions de process simultann√©ment pour g√©rer un grand flux d'information
* ils disposent d'un syst√®me de communication inter-processus ‚Äì dit _par messages_ tr√®s performant et automatis√©
* il profitent de la s√©curit√© qu'offre la _m√©moire immutable_ de la VM

<!-- livebook:{"break_markdown":true} -->

Ainsi, chaque processus Erlang cr√©√© obtient les ressources suivantes:

* un identifiant unique, dit "Process ID" ou "**PID**" qui permet de le retrouver et de lui envoyer des messages
* une "bo√Æte aux lettres" ("**Mailbox**") qui stockera automatiquement tous les messages adress√©s √† ce process

le sch√©ma suivant illustre **la communcation entre plusieurs process**:

```mermaid
flowchart LR
  subgraph VM[BEAM VM]
    A[Processus A <br> PID <0.101.0> <br> Mailbox]:::proc -->|message| B[Processus B <br> PID <0.102.0> <br>  Mailbox]:::proc
    C[Processus C <br> PID <0.103.0> <br> Mailbox]:::proc -->|message| B
  end
  
  classDef proc fill:#e5f6ff,stroke:#0284c7,stroke-width:2px,rx:8,ry:8;
```

<!-- livebook:{"break_markdown":true} -->

### Affichage des PIDs

Tout cel√† peut para√Ætre tr√®s abstrait, mais nous allons maintenant illustrer ces concepts.

Le Livebook que vous ex√©cutez est un programme Elixir, et _votre notebook s'ex√©cute dans un process Elixir_.

Nous pouvons utiliser [`self/0`](https://hexdocs.pm/elixir/Kernel.html#self/0) pour afficher le **PID** du process responsable de la cellule suivante:

```elixir
self()
```

√âvidemment, nous pouvons d√©marrer de nouveaux process via une commande d√©di√©e ‚Äì [`spawn/1`](https://hexdocs.pm/elixir/Kernel.html#spawn/1) ‚Äì qui va cr√©er un nouveau processus puis lancer la fonction pass√©e en argument _au sein de ce nouveau processus_:

```elixir
IO.inspect self(), label: "PID du process parent"

pid_du_nouveau_process = spawn(fn ->
  IO.puts "Coucou depuis le nouveau process !"

  #          üëá cet appel √† self() est ex√©cut√© dans le nouveau process et sera donc diff√©rent
  IO.inspect self(), label: "PID du process parent"
end)
```

Vous devriez avoir un r√©sultat qui ressemble au suivant:

![](files/pids-parent-child.png)

üí° Quelques remarques avant de continuer:

* l'appel √† `self/0` retourne toujours le PID du process _courant_: c'est pourquoi elle renvoie un r√©sultat diff√©rent lorsqu'elle est appel√©e dans le nouveau processus cr√©√© par `spawn/1`
* le PID du nouveau processus est √©galement _retourn√©_ par l'appel √† `spawn/1` _au parent_: l'int√©r√™t √©tant que gr√¢ce √† ce PID le parent pourra envoyer des messages au process enfant !

## Communication entre les processus

Une fois le PID du process avec lequel nous essayons de communiqu√© connu, il reste deux op√©rations √† mener:

1. envoyer un _message_ au processus
2. au sein de ce processus _capturer_ le message re√ßu

<!-- livebook:{"break_markdown":true} -->

Pour se faire, Elixir dispose de fonctionnalit√©s d√©di√©es:

* la fonction [`send/2`](https://hexdocs.pm/elixir/Kernel.html#send/2) qui prend un PID et un message (n'importe quelle valeur Elixir) √† envoyer
* la fonction [`receive/1`](https://hexdocs.pm/elixir/Kernel.SpecialForms.html#receive/1) qui prend un bloc de fonctions √† pattern-matcher avec ce message (pensez au fonctionnement de [`case`](https://hexdocs.pm/elixir/case-cond-and-if.html#case))

L'exemple tr√®s simple ci-dessous continue l√† o√π nous avions commenc√© :

```elixir
# on d√©marre un processus enfant
enfant = spawn(fn ->
  receive do
    message ->
      IO.inspect(message, label: "ENFANT")
  end
end)

# envoyons un message √† l'enfant:
send(enfant, "Coucou")
```

Nous avons donc le process parent qui envoie un message au process enfant, et ce dernier, lorqu'il le re√ßoit dans son bloc `receive` va afficher un message dans la console.

Afin d'illustrer ce fonctionnement, nous pouvons r√©-utiliser le code pr√©c√©dent dans une fonction sp√©cifique `TP.trace/1` (sp√©cifique √† ce TP et bas√©e sur [`Kino.Process.render_sql_trace/1`](https://hexdocs.pm/kino/0.16.1/Kino.Process.html#render_seq_trace/3)) de Livebook qui permet de tracer l'ex√©cution en d√©tail:

```elixir
TP.trace(fn ->
  
  enfant = spawn(fn ->
    receive do
      message ->
        IO.inspect(message, label: "ENFANT")
    end
  end)
  
  send(enfant, "Coucou")
  
end)
```

On voit que tout fonctionne bien, dans un sens. Il reste cependant une question: comment faire pour que le process enfant puisse "r√©pondre" au parent ?

La solution la plus simple consiste √† passer le process parent par _closure_, c'est-√†-dire une variable d√©finie avant la fonction et qui fera partie de son contexte d'ex√©cuption, illustration:

```elixir
# on sauvetarde le PID du parent dans une variable
parent = self()

TP.trace(parent, fn ->
  
  enfant =
    # Cette fonction anonyme √©tant d√©finie "apr√®s" la variable et peut la r√©f√©rencer
    # ici la r√©f√©rence vers "parent" est pass√© implicitement √† la fonction via son context de
    # d√©claration: on parle de "fermeture" ou "closure" en anglais.
    spawn(fn ->
      receive do
        message ->
          IO.inspect(message, label: "ENFANT")

          # renvoi du message au parent, dont on conna√Æt d√©sormais le PID
          send(parent, "Coucou toi aussi")
      end
    end)

  # Envoi du message √† l'enfant
  send(enfant, "Coucou")

  # Attente d'un message de la part de l'enfant
  receive do
    message -> message  
  end
  
end)
```

### Exercice

Reprenez le code pr√©c√©dent, mais supprimez la variable `parent` au d√©but du programme. Vous devez modifier le code pour **envoyer un message qui contienne √† la voir la cha√Æne de caract√®res √† afficher et √©galement le PID** auquel il doit r√©pondre.

```elixir
enfant =
  spawn(fn ->
    receive do
      # √Ä COMPL√âTER
    end
  end)

# √Ä COMPL√âTER
send(enfant, "???")

# √Ä D√âCOMMENTER QUAND VOUS √äTES PR√äT
# receive do
#   message -> message
# end
```

```elixir
# CORRECTION POSSIBLE

enfant =
  spawn(fn ->
    receive do
      {pid, msg} ->
        IO.puts(msg)
        send(pid, :ok)
    end
  end)

# √Ä COMPL√âTER
send(enfant, {self(), "Coucou avec r√©ponse"})

# Attente d'un message de la part de l'enfant
receive do
  message -> message
end
```

## Un "long-lived process"

Dans tous nos exemples ci-dessus, nos processus s'arr√™tent d√®s la fin de l'ex√©cution de la fonction. Cependant, il serait int√©ressant d'avoir des processus capables de traiter _plusieurs messages_ d'affil√©e sans s'arr√™ter.

Pour cela, nous allons utiliser deux fonctionnalit√©s d'√âlixir que nous avons d√©j√† rencontr√©s:

* les **modules**
* et la **r√©cursion** üî•

Il est alors possible d'utiliser [`spawn/3`](https://hexdocs.pm/elixir/Kernel.html#spawn/3) avec *trois arguments* pour invoquer la fonction dans notre module. La syntaxe est la suivante:

![](files/spawn-3.png)

Voyons un exemple:

```elixir
defmodule LongLivedProcess do

  # Notre fonction prend deux argument: un nom √† afficher dans la console, 
  # et un nombre de boucles √† effectuer
  def loop(name, count) do
    
    # Attente du message
    receive do

      # Pattern-matching: on s'attend √† recevoir un tuple { PID, string }
      {pid, message} ->
        IO.puts "#{name}: Received #{message} from #{inspect(pid)}"

        response =
          case message do
            :ping -> :pong # si on re√ßoit :ping, on renvoie :pong
            :pong -> :ping # si on re√ßoit :pong, on renvoie :ping
          end
        send(pid, { self(), response })
    end

    # Pour √©viter de cr√©er des "boucles infinies" on d√©cr√©mente le compteur √† chaque it√©ration
    if count > 0 do
      loop(name, count-1)
    end
    
  end
  
end
```

Pour ex√©cuter ce code, nous allons cr√©er deux processus enfants et les faire communiquer entre eux.

üí° Vous verrez appara√Ætre un process suppl√©mentaire sur ce sh√©ma, qui recoit des message `io_request` et `io_reply`: il s'agit du process qui g√®re l'affichage des logs dans la cellule de Livebook (quand vous appelez `IO.puts/1`). Vous pouvez l'ignorer.

En pratique:

```elixir
# On cr√©e deux process
process1 = spawn(LongLivedProcess, :loop, ["PROCESS1", 3])
process2 = spawn(LongLivedProcess, :loop, ["PROCESS2", 3])

# On affiche leur PIDs (pour aider √† suivre l'ex√©cution)
IO.inspect(process1, label: "PID du PROCESS1")
IO.inspect(process2, label: "PID du PROCESS2")

TP.trace([process1, process2], fn ->
  
  # on "lance la machine" en simulant l'envoi d'un message du process 1 au process 2
  send(process2, {process1, :ping})

  # on bloque 300ms pour "attendre" que tous les messages soient envoy√©s
  Process.sleep(300)
  
end)
```

## Exercice d'application: MapReduce simple

Nous allons terminer ce TP en cr√©ant un premier module d'ex√©cution distribut√©e.

**Objectif**: nous allons cr√©er un programme qui va "compter le nombre de mots" dans un texte". Et nous alons de faire de fa√ßon _concurrente_, en s√©parant le travail entre plusieurs process.

* nous allons utiliser une approche "MapReduce"
* nous appelons la fonction `MapReduce1.run/1` en lui passant une liste de textes √† analyzer
* pour chaque texte, nous lan√ßons un processus d'analyze (dans `start_all/1`)
* puis dans `gather` nous attendons toutes les r√©ponses pour finaliser le calcul final

```mermaid
flowchart LR
  D[textes]
  M["texts |> start_all |> gather"]

  D -->|run| M

  M -->|spawn| W1[Worker #1]:::worker
  M -->|spawn| W2[Worker #2]:::worker
  M -->|spawn| Wn[Worker #n]:::worker

  W1 -->|"{:result, ..., count}"| M
  W2 -->|"{:result, ..., count}"| M
  Wn -->|"{:result, ..., count}"| M
```

Voici le code √† compl√©ter:

```elixir
defmodule MapReduce1 do
  # Map ‚Üí Reduce
  def run(texts) do
    texts |> start_all() |> gather()
  end

  # TODO
  def start_all(texts) do
    [] # TODO: lancer les process worker et retourner la liste des PIDs
  end

  # TODO: d√©terminer les arguments √† passer
  def worker(:todo) do
    # TODO: 
    # - compter les mots du texte
    # - r√©pondre au parent avec le r√©sultat: format sugg√©r√© {:result, pid_worker, count_des_mots} 
  end

  # 4) Boucle d'agr√©gation: re√ßoit results et DOWN, relance si besoin
  defp gather(pids) do
    # TODO:
    # - attendre les r√©sultats des workers
    # - additioner les r√©sultats de chaque worker
    # - retourner le r√©sultat final
    0
  end

  # Cadeau üéÅ
  defp count_words(text) do
    text
    |> String.downcase()
    |> String.replace(~r/[^[:alnum:]\p{L}\s-]/u, " ")
    |> String.split(~r/\s+/, trim: true)
    |> Enum.count()
  end
end
```

```elixir
haiku_dakotsu = [
  "Du temps pass√©", 
  "Me revient le souvenir", 
  "Les biches au printemps."
]

TP.trace(self(), fn ->
  MapReduce1.run(haiku_dakotsu)
end)
```

```elixir
lac_lamartine = [
  "Ainsi, toujours pouss√©s vers de nouveaux rivages,",
  "Dans la nuit √©ternelle emport√©s sans retour,",
  "Ne pourrons-nous jamais sur l'oc√©an des √¢ges",
  "Jeter l'ancre un seul jour ?",

  "√î lac ! l'ann√©e √† peine a fini sa carri√®re,",
  "Et pr√®s des flots ch√©ris qu'elle devait revoir,",
  "Regarde ! je viens seul m'asseoir sur cette pierre",
  "O√π tu la vis s'asseoir !",

  "Tu mugissais ainsi sous ces roches profondes ;",
  "Ainsi tu te brisais sur leurs flancs d√©chir√©s ;",
  "Ainsi le vent jetait l'√©cume de tes ondes",
  "Sur ses pieds ador√©s.",

  "Un soir, t'en souvient-il ? nous voguions en silence ;",
  "On n'entendait au loin, sur l'onde et sous les cieux,",
  "Que le bruit des rameurs qui frappaient en cadence",
  "Tes flots harmonieux.",

  "Tout √† coup des accents inconnus √† la terre",
  "Du rivage charm√© frapp√®rent les √©chos ;",
  "Le flot fut attentif, et la voix qui m'est ch√®re",
  "Laissa tomber ces mots :",


  "√î temps ! suspends ton vol, et vous, heures propices,",
  "Suspendez votre cours !",
  "Laissez-nous savourer les rapides d√©lices",
  "Des plus beaux de nos jours !",

  "Assez de malheureux ici-bas vous implorent ;",
  "Coulez, coulez pour eux ;",
  "Prenez avec leurs jours les soins qui les d√©vorent ;",
  "Oubliez les heureux.",

  "Mais je demande en vain quelques moments encore,",
  "Le temps m'√©chappe et fuit ;",
  "Je dis √† cette nuit : Sois plus lente ; et l'aurore",
  "Va dissiper la nuit.",

  "Aimons donc, aimons donc ! de l'heure fugitive,",
  "H√¢tons-nous, jouissons !",
  "L'homme n'a point de port, le temps n'a point de rive ;",
  "Il coule, et nous passons !",

  "Temps jaloux, se peut-il que ces moments d'ivresse,",
  "O√π l'amour √† longs flots nous verse le bonheur,",
  "S'envolent loin de nous de la m√™me vitesse",
  "Que les jours de malheur ?",

  "H√© quoi ! n'en pourrons-nous fixer au moins la trace ?",
  "Quoi ! pass√©s pour jamais ! quoi ! tout entiers perdus !",
  "Ce temps qui les donna, ce temps qui les efface,",
  "Ne nous les rendra plus !",

  "√âternit√©, n√©ant, pass√©, sombres ab√Æmes,",
  "Que faites-vous des jours que vous engloutissez ?",
  "Parlez : nous rendrez-vous ces extases sublimes",
  "Que vous nous ravissez ?",

  "√î lac ! rochers muets ! grottes ! for√™t obscure !",
  "Vous, que le temps √©pargne ou qu'il peut rajeunir,",
  "Gardez de cette nuit, gardez, belle nature,",
  "Au moins le souvenir !",

  "Qu'il soit dans ton repos, qu'il soit dans tes orages,",
  "Beau lac, et dans l'aspect de tes riants coteaux,",
  "Et dans ces noirs sapins, et dans ces rocs sauvages",
  "Qui pendent sur tes eaux.",

  "Qu'il soit dans le z√©phyr qui fr√©mit et qui passe,",
  "Dans les sons de tes bords par tes rivages port√©s,",
  "Dans l'astre au front d'argent qui blanchit ta surface",
  "De ses molles clart√©s !",

  "Que le vent qui g√©mit, le roseau qui soupire,",
  "Que les parfums l√©gers de ton air embaum√©,",
  "Que tout ce qu'on entend, l'on voit et l'on respire,",
  "Tout dise : Ils ont aim√© !"
]

# Avec trace visuel (optionnel)
TP.trace(self(), fn ->
  MapReduce1.run(lac_lamartine)
end)
```
