# C1N3 ‚Äì Le module Task

```elixir
Mix.install([
  {:kino, "~> 0.16.1"},
  {:req, "~> 0.5.15"},
  {:merquery, "~> 0.3.0"},
  {:nx, "~> 0.10.0"},
  {:nx_image, "~> 0.1.2"},
  {:image, "~> 0.62.0"}
])
```

## Motivation

Dans les notebooks pr√©c√©dents, nous avons d√©couvert les bases de la concurrence en Elixir √† travers les processus l√©gers (processus BEAM), la fonction [`spawn/1`](https://hexdocs.pm/elixir/Kernel.html#spawn/1) et l‚Äôenvoi/r√©ception de messages.

D√©sormais, il est temps de construire sur ces notions fondamentales et d‚Äôexplorer un outil haut niveau fourni par Elixir pour simplifier l‚Äôex√©cution concurrente : le module [`Task`](https://hexdocs.pm/elixir/Task.html). Ce module offre des fonctions pr√™tes √† l‚Äôemploi pour lancer des t√¢ches asynchrones et en r√©cup√©rer facilement les r√©sultats, sans avoir √† g√©rer explicitement les messages entre processus.

## Exemple : Utilisation de Task.async et Task.await

Comparons une utilisation simple du module `Task` par rapport √† l'approche vue pr√©c√©demment:

```elixir
# Lance une t√¢che
task =
  Task.async(fn ->
    # Simule un calcul long de 1 seconde
    Process.sleep(1000)
    5 * 5
  end)

IO.puts("T√¢che lanc√©e pour calculer 5^2 ...")

# Ici, on pourrait faire d'autres op√©rations pendant que la t√¢che s'ex√©cute...

# R√©cup√©rer le r√©sultat de la t√¢che (cela bloque jusqu'√† ce que ce soit pr√™t)
result = Task.await(task)
IO.puts("R√©sultat obtenu : #{result}")
```

On remarque imm√©diatement:

* que l'appel √† [`Task.async/1`](https://hexdocs.pm/elixir/Task.html#async/1) a remplac√© les appels √† [`spawn/1`](https://hexdocs.pm/elixir/Kernel.html#spawn/1)/[`spawn_link/1`](https://hexdocs.pm/elixir/Kernel.html#spawn_link/1)
* qu'il n'y a plus de bloc [`receive do ... end`](https://hexdocs.pm/elixir/Kernel.SpecialForms.html#receive/1): c'est d√©sormais [`Task.await/1`](https://hexdocs.pm/elixir/Task.html#await/1) qui se charge de r√©cup√©rer le r√©sultat de la commande lanc√©e plus t√¥t

üí° Lorsqu‚Äôon utilise [`Task.async/1`](https://hexdocs.pm/elixir/Task.html#async/1), la t√¢che lanc√©e est _li√©e au processus appelant_ !

<!-- livebook:{"break_markdown":true} -->

On pourrait d'ailleurs lancer plusieurs t√¢ches en parall√®le, sans perturber le fonctionnement du processus parent:

```elixir
sleep_and_square = fn ->
  n = :rand.uniform(5) # nombre al√©ratoire entre 1 et 5
  Process.sleep(n * 1000)
  n * n
end

# lancement des t√¢ches
task1 = Task.async(sleep_and_square)
task2 = Task.async(sleep_and_square)

# R√©cup√©ration des r√©sultats une fois pr√™ts
result1 = Task.await(task1)
result2 = Task.await(task2)
IO.puts("R√©sultat obtenu (t√¢che n¬∞1) : #{result1}")
IO.puts("R√©sultat obtenu (t√¢che n¬∞1) : #{result2}")
```

Le fonctionnement global est illustr√© dans le sch√©ma ci-dessous:

<!-- livebook:{"break_markdown":true} -->

```mermaid
sequenceDiagram
    participant Principal
    participant T√¢che1
    participant T√¢che2

    Note over Principal,T√¢che1: D√©marrage de la premi√®re t√¢che
    Principal->>T√¢che1: Task.async(fn1)
    Note right of T√¢che1: T√¢che1 d√©marre en arri√®re-plan

    Note over Principal,T√¢che2: D√©marrage de la deuxi√®me t√¢che
    Principal->>T√¢che2: Task.async(fn2)
    Note right of T√¢che2: T√¢che2 d√©marre en arri√®re-plan

    Note over Principal: (Le processus principal continue son ex√©cution...)

    T√¢che1-->>Principal: renvoie le r√©sultat1 (termin√©)
    T√¢che2-->>Principal: renvoie le r√©sultat2 (termin√©)

    Principal->>Principal: Task.await(resultat1) <br/> Task.await(resultat2) 
    Note over Principal: R√©cup√©ration des r√©sultats une fois pr√™ts
```

<!-- livebook:{"break_markdown":true} -->

üí° il existe √©galement une fonction [`Task.await_many/1`](https://hexdocs.pm/elixir/Task.html#await_many/2) qui permet d'attendre le r√©sultat de plusieurs t√¢ches en une seule commande (ici avec `Task.await_many([task1, task2])`).

## Pourquoi organiser son code ainsi ?

Toujours dans un sc√©nario o√π nous lan√ßons des t√¢ches "longues" ‚Äì par ex. des calculs ou des requ√™tes sur internet ‚Äì il devient rapidement int√©ressant de "parall√©liser" l'ex√©cution de notre code afin de gagner en performance.

Comparons l'approche avec parall√©lisation et l'approche synchrone:

```elixir
# Nos t√¢ches longue dur√©e
tache_a = fn -> Process.sleep(2000); "Op√©ration 1 termin√©e" end
tache_b = fn -> Process.sleep(2000); "Op√©ration 2 termin√©e" end
```

```elixir
# ex√©cution synchrone
temps_depart_ms = System.monotonic_time(:millisecond)

tache_a.()
tache_b.()

duree_ms = System.monotonic_time(:millisecond) - temps_depart_ms
IO.puts "Dur√©e d'ex√©cution: #{duree_ms}ms"
```

```elixir
# ex√©cution concurrente
temps_depart_ms = System.monotonic_time(:millisecond)

# Lancement des t√¢ches
task1 = Task.async(tache_a)
task2 = Task.async(tache_b)

# Attente des r√©sultats
Task.await_many([task1, task2])

duree_ms = System.monotonic_time(:millisecond) - temps_depart_ms
IO.puts "Dur√©e d'ex√©cution: #{duree_ms}ms"
```

On comprend imm√©diatement l'int√©r√™t de la seconde approche: le temps d'ex√©cution n'est plus la somme des temps individuels des diff√©rents t√¢ches, mais devient (√† quelques ms pr√®s) la dur√©e de la t√¢che la plus longue.

On peut l'illustrer par le sch√©ma:

<!-- livebook:{"break_markdown":true} -->

```mermaid
gantt
    dateFormat  ss
    axisFormat  %Ss
    section S√©quentiel
    T√¢che_A :done, seq1, 00, 2s
    T√¢che_B :done, seq2, after seq1, 2s
    section Parall√®le
    T√¢che_A :done, par1, 00, 2s
    T√¢che_B :done, par2, 00, 2s
```

<!-- livebook:{"break_markdown":true} -->

Nous allons maintenant illustrer tout √ßa sur un exemple plus concret:

<!-- livebook:{"branch_parent_index":0} -->

## Faire des requ√™tes HTTP (internet) avec Elixir

Nous allons maintenant charger des donn√©es depuis internet: il vous faudra √©videmment une connexion fonctionnelle pour continuer ce TP, m√™me si nous ne chargerons que peu de donn√©es en preatique !

Nous allons utiliser deux ressources externes:

* la librairie [`Req`](https://hexdocs.pm/req/readme.html) d'Elixir, qui est la fa√ßon standard ("haut niveau") de faire des requ√™tes sur internet
* l'API publique "[Pok√©API](https://pokeapi.co/)" qui propose gratuitement une base de donn√©es sur les personnages des jeux Pokemon

## Exercice: chargement d'informations sur un Pokemon

Nous allons charger les informations sur le pokemon `pikachu` en effectuant:

* un recherche de type "GET"
* √† l'adresse `https://pokeapi.co/api/v2/pokemon/pikachu`

Compl√©tez les param√®tre dans l'interface ci-dessous pour effectuer votre appel:

<!-- livebook:{"attrs":"eyJxdWVyaWVzIjpbeyJhdXRoIjp7InNjaGVtZSI6Im5vbmUiLCJ0eXBlIjowLCJ2YWx1ZSI6IiJ9LCJib2R5Ijp7ImNvbnRlbnRUeXBlIjoibm9uZSIsImZvcm0iOltdLCJyYXciOiIifSwiaGVhZGVycyI6W10sIm9wdGlvbnMiOnsiY29udGVudFR5cGUiOiJlbGl4aXIiLCJyYXciOiIifSwicGFyYW1zIjpbXSwicGx1Z2lucyI6W3siYWN0aXZlIjpmYWxzZSwiZGVzY3JpcHRpb24iOiJBIGNvbGxlY3Rpb24gb2Ygc3RlcHMsIHVzYWJsZSB3aXRoIFJlcS4iLCJuYW1lIjoiQ3VybFJlcS5QbHVnaW4iLCJ2ZXJzaW9uIjpudWxsfV0sInJlcXVlc3RfdHlwZSI6ImdldCIsInN0ZXBzIjp7ImVycm9yX3N0ZXBzIjpbeyJhY3RpdmUiOnRydWUsImRvYyI6IlJldHJpZXMgYSByZXF1ZXN0IGluIGZhY2Ugb2YgZXJyb3JzLiIsIm5hbWUiOiJyZXRyeSJ9XSwicmVxdWVzdF9zdGVwcyI6W3siYWN0aXZlIjp0cnVlLCJkb2MiOiJTZXRzIHRoZSB1c2VyLWFnZW50IGhlYWRlci4iLCJuYW1lIjoicHV0X3VzZXJfYWdlbnQifSx7ImFjdGl2ZSI6dHJ1ZSwiZG9jIjoiQXNrcyB0aGUgc2VydmVyIHRvIHJldHVybiBjb21wcmVzc2VkIHJlc3BvbnNlLiIsIm5hbWUiOiJjb21wcmVzc2VkIn0seyJhY3RpdmUiOnRydWUsImRvYyI6IkVuY29kZXMgdGhlIHJlcXVlc3QgYm9keS4iLCJuYW1lIjoiZW5jb2RlX2JvZHkifSx7ImFjdGl2ZSI6dHJ1ZSwiZG9jIjoiU2V0cyBiYXNlIFVSTCBmb3IgYWxsIHJlcXVlc3RzLiIsIm5hbWUiOiJwdXRfYmFzZV91cmwifSx7ImFjdGl2ZSI6dHJ1ZSwiZG9jIjoiU2V0cyByZXF1ZXN0IGF1dGhlbnRpY2F0aW9uLiIsIm5hbWUiOiJhdXRoIn0seyJhY3RpdmUiOnRydWUsImRvYyI6IkFkZHMgcGFyYW1zIHRvIHJlcXVlc3QgcXVlcnkgc3RyaW5nLiIsIm5hbWUiOiJwdXRfcGFyYW1zIn0seyJhY3RpdmUiOnRydWUsImRvYyI6IlVzZXMgYSB0ZW1wbGF0ZWQgcmVxdWVzdCBwYXRoLiIsIm5hbWUiOiJwdXRfcGF0aF9wYXJhbXMifSx7ImFjdGl2ZSI6dHJ1ZSwiZG9jIjoiU2V0cyB0aGUgXCJSYW5nZVwiIHJlcXVlc3QgaGVhZGVyLiIsIm5hbWUiOiJwdXRfcmFuZ2UifSx7ImFjdGl2ZSI6dHJ1ZSwiZG9jIjoiUGVyZm9ybXMgSFRUUCBjYWNoaW5nIHVzaW5nIGBpZi1tb2RpZmllZC1zaW5jZWAgaGVhZGVyLiIsIm5hbWUiOiJjYWNoZSJ9LHsiYWN0aXZlIjp0cnVlLCJkb2MiOiJTZXRzIGFkYXB0ZXIgdG8gYHJ1bl9wbHVnLzFgLiIsIm5hbWUiOiJwdXRfcGx1ZyJ9LHsiYWN0aXZlIjp0cnVlLCJkb2MiOiJDb21wcmVzc2VzIHRoZSByZXF1ZXN0IGJvZHkuIiwibmFtZSI6ImNvbXByZXNzX2JvZHkifSx7ImFjdGl2ZSI6dHJ1ZSwiZG9jIjoiU2V0cyBleHBlY3RlZCByZXNwb25zZSBib2R5IGNoZWNrc3VtLiIsIm5hbWUiOiJjaGVja3N1bSJ9LHsiYWN0aXZlIjp0cnVlLCJkb2MiOiJTaWducyByZXF1ZXN0IHdpdGggQVdTIFNpZ25hdHVyZSBWZXJzaW9uIDQuIiwibmFtZSI6InB1dF9hd3Nfc2lndjQifV0sInJlc3BvbnNlX3N0ZXBzIjpbeyJhY3RpdmUiOnRydWUsImRvYyI6IlJldHJpZXMgYSByZXF1ZXN0IGluIGZhY2Ugb2YgZXJyb3JzLiIsIm5hbWUiOiJyZXRyeSJ9LHsiYWN0aXZlIjp0cnVlLCJkb2MiOiJIYW5kbGVzIEhUVFAgNHh4LzV4eCBlcnJvciByZXNwb25zZXMuIiwibmFtZSI6ImhhbmRsZV9odHRwX2Vycm9ycyJ9LHsiYWN0aXZlIjp0cnVlLCJkb2MiOiJGb2xsb3dzIHJlZGlyZWN0cy4iLCJuYW1lIjoicmVkaXJlY3QifSx7ImFjdGl2ZSI6dHJ1ZSwiZG9jIjoiRGVjb21wcmVzc2VzIHRoZSByZXNwb25zZSBib2R5IGJhc2VkIG9uIHRoZSBgY29udGVudC1lbmNvZGluZ2AgaGVhZGVyLiIsIm5hbWUiOiJkZWNvbXByZXNzX2JvZHkifSx7ImFjdGl2ZSI6dHJ1ZSwiZG9jIjoiVmVyaWZpZXMgdGhlIHJlc3BvbnNlIGJvZHkgY2hlY2tzdW0uIiwibmFtZSI6InZlcmlmeV9jaGVja3N1bSJ9LHsiYWN0aXZlIjp0cnVlLCJkb2MiOiJEZWNvZGVzIHJlc3BvbnNlIGJvZHkgYmFzZWQgb24gdGhlIGRldGVjdGVkIGZvcm1hdC4iLCJuYW1lIjoiZGVjb2RlX2JvZHkifSx7ImFjdGl2ZSI6dHJ1ZSwiZG9jIjpudWxsLCJuYW1lIjoib3V0cHV0In1dfSwidXJsIjoiaHR0cHM6Ly9wb2tlYXBpLmNvL2FwaS92Mi9wb2tlbW9uL3Bpa2FjaHUiLCJ2YXJpYWJsZSI6InJlc3AiLCJ2ZXJicyI6WyJnZXQiLCJwb3N0IiwicHV0IiwicGF0Y2giLCJkZWxldGUiLCJoZWFkIiwib3B0aW9ucyJdfV0sInF1ZXJ5SW5kZXgiOjB9","chunks":null,"kind":"Elixir.Merquery.SmartCell","livebook_object":"smart_cell"} -->

```elixir
req =
  Req.new(
    method: :get,
    url: "https://pokeapi.co/api/v2/pokemon/pikachu",
    headers: %{},
    params: %{}
  )
{req, resp} = Req.request(req)
resp
```

Vous devriez obtenir un objet de type "Map" dans la variables `resp` contenant toute une s√©rie de param√®tres.,

* arrivez-vous √† comprendre les diff√©rentes informations charg√©e depuis internet
* en particulier, arrivez-vous √† retrouver les informations sur les _images tir√©es du jeu_ ?

<!-- livebook:{"break_markdown":true} -->

Votre _mission_ est d√©sormais de compl√©ter le code ci-apr√®s, afin d'extraire une _liste_ de toutes les adresses de toutes les images du pokemon:

```elixir
defmodule SpriteExtractor do

  def get_sprites(resp) do
    []
  end
  
end
```

Si votre code fonctionne correctement, vous devriez pouvoir ex√©cuter la cellule suivante pour charger toutes les images:

```elixir
sprites = SpriteExtractor.get_sprites(resp)

# Construit un document "markdown" avec toutes nos images
images = for x <- sprites do
  Kino.Markdown.new("![](#{x})")
end
Kino.Layout.grid(images, columns: 6)
```

### Deuxi√®me partie de l'exercice: analyser les images entrantes

Il est temps de charger les image "pour de vrai" et pas seulement les _adresses internet_ de ces images.

Pour se faire, nous allons:

1. repartir de notre liste d'adresses `sprites` obtenue √† l'exercice pr√©c√©dent
2. lancer des t√¢ches pour de chargement des donn√©es de l'image avec [`Req.get!/1`](https://hexdocs.pm/req/Req.html#get!/2) et r√©cup√©rer le "body" de la r√©ponse qui contient les donn√©es de l'image
3. Charger les images avec [`Image.from_binary!/1`](https://hexdocs.pm/image/0.62.0/Image.html#from_binary!/2) puis les transformer en images "affichables" avec [`Image.Kino.show/1`](https://hexdocs.pm/image/0.62.0/Image.Kino.html#show/2)

```elixir
# Premi√®re t√¢che: charger les images en parall√®le
tasks = []

raw_images = Task.await_many(tasks)
```

```elixir
# Deuxi√®me t√¢che: transformer les donn√©es "brutes" en images
images = []

Kino.Layout.grid(images, columns: 6)
```


