# C1N3 ‚Äì Le module Task

```elixir
Mix.install([
  {:kino, "~> 0.16.1"},
  {:req, "~> 0.5.15"},
  {:merquery, "~> 0.3.0"}
])
```

## Motivation

Dans les notebooks pr√©c√©dents, nous avons d√©couvert les bases de la concurrence en Elixir √† travers les processus l√©gers (processus BEAM), la fonction [`spawn/1`](https://hexdocs.pm/elixir/Kernel.html#spawn/1) et l‚Äôenvoi/r√©ception de messages.

D√©sormais, il est temps de construire sur ces notions fondamentales et d‚Äôexplorer un outil haut niveau fourni par Elixir pour simplifier l‚Äôex√©cution concurrente : le module [`Task`](https://hexdocs.pm/elixir/Task.html).

Ce module offre des fonctions pr√™tes √† l‚Äôemploi pour lancer des t√¢ches asynchrones et en r√©cup√©rer facilement les r√©sultats, sans avoir √† g√©rer explicitement les messages entre processus.

Nous allons dans ce qui suit pr√©senter le module Task, illustrer la diff√©rence entre une ex√©cution s√©quentielle et parall√®le, et pratiquer avec des exercices plus complets.

<!-- livebook:{"break_markdown":true} -->

### Module Task vs ex√©cution synchrone

Elixir fournit le module Task pour faciliter l‚Äôex√©cution de fonctions de fa√ßon **asynchrone** ‚Äì c‚Äôest-√†-dire concurrente, dans un processus s√©par√© ‚Äì et la r√©cup√©ration de leur r√©sultat ult√©rieurement.

En interne, lancer un Task revient √† cr√©er un nouveau processus, comme avec spawn, mais Task nous √©vite de g√©rer manuellement les messages de retour : il s‚Äôoccupe de lier le processus, d‚Äôenvoyer le r√©sultat ou l‚Äôerreur, et fournit des fonctions pour attendre ce r√©sultat proprement.

## Exemple : Utilisation de Task.async et Task.await

Comparons une utilisation simple du module `Task` par rapport √† l'approche vue pr√©c√©demment:

```elixir
# Lance une t√¢che
task =
  Task.async(fn ->
    # Simule un calcul long de 1 seconde
    Process.sleep(1000)
    5 * 5
  end)

IO.puts("T√¢che lanc√©e pour calculer 5^2 ...")

# Ici, on pourrait faire d'autres op√©rations pendant que la t√¢che s'ex√©cute...

# R√©cup√©rer le r√©sultat de la t√¢che (cela bloque jusqu'√† ce que ce soit pr√™t)
result = Task.await(task)
IO.puts("R√©sultat obtenu : #{result}")
```

On remarque imm√©diatement:

* que l'appel √† [`Task.async/1`](https://hexdocs.pm/elixir/Task.html#async/1) a remplac√© les appels √† [`spawn/1`](https://hexdocs.pm/elixir/Kernel.html#spawn/1)/[`spawn_link/1`](https://hexdocs.pm/elixir/Kernel.html#spawn_link/1)
* qu'il n'y a plus de bloc [`receive do ... end`](https://hexdocs.pm/elixir/Kernel.SpecialForms.html#receive/1): c'est d√©sormais [`Task.await/1`](https://hexdocs.pm/elixir/Task.html#await/1) qui se charge de r√©cup√©rer le r√©sultat de la commande lanc√©e plus t√¥t

üí° Lorsqu‚Äôon utilise [`Task.async/1`](https://hexdocs.pm/elixir/Task.html#async/1), la t√¢che lanc√©e est _li√©e au processus appelant_ !

<!-- livebook:{"break_markdown":true} -->

On pourrait d'ailleurs lancer plusieurs t√¢ches en parall√®le, sans perturber le fonctionnement du processus parent:

```elixir
sleep_and_square = fn ->
  n = :rand.uniform(5) # nombre al√©ratoire entre 1 et 5
  Process.sleep(n * 1000)
  n * n
end

# lancement des t√¢ches
task1 = Task.async(sleep_and_square)
task2 = Task.async(sleep_and_square)

# R√©cup√©ration des r√©sultats une fois pr√™ts
result1 = Task.await(task1)
result2 = Task.await(task2)
IO.puts("R√©sultat obtenu (t√¢che n¬∞1) : #{result1}")
IO.puts("R√©sultat obtenu (t√¢che n¬∞1) : #{result2}")
```

Le fonctionnement global est illustr√© dans le sch√©ma ci-dessous:

<!-- livebook:{"break_markdown":true} -->

```mermaid
sequenceDiagram
    participant Principal
    participant T√¢che1
    participant T√¢che2

    Note over Principal,T√¢che1: D√©marrage de la premi√®re t√¢che
    Principal->>T√¢che1: Task.async(fn1)
    Note right of T√¢che1: T√¢che1 d√©marre en arri√®re-plan

    Note over Principal,T√¢che2: D√©marrage de la deuxi√®me t√¢che
    Principal->>T√¢che2: Task.async(fn2)
    Note right of T√¢che2: T√¢che2 d√©marre en arri√®re-plan

    Note over Principal: (Le processus principal continue son ex√©cution...)

    T√¢che1-->>Principal: renvoie le r√©sultat1 (termin√©)
    T√¢che2-->>Principal: renvoie le r√©sultat2 (termin√©)

    Principal->>Principal: Task.await(resultat1) <br/> Task.await(resultat2) 
    Note over Principal: R√©cup√©ration des r√©sultats une fois pr√™ts
```

<!-- livebook:{"break_markdown":true} -->

üí° il existe √©galement une fonction [`Task.await_many/1`](https://hexdocs.pm/elixir/Task.html#await_many/2) qui permet d'attendre le r√©sultat de plusieurs t√¢ches en une seule commande (ici avec `Task.await_many([task1, task2])`).

## Pourquoi organiser son code ainsi ?

Toujours dans un sc√©nario o√π nous lan√ßons des t√¢ches "longues" ‚Äì par ex. des calculs ou des requ√™tes sur internet ‚Äì il devient rapidement int√©ressant de "parall√©liser" l'ex√©cution de notre code afin de gagner en performance.

Comparons l'approche avec parall√©lisation et l'approche synchrone:

```elixir
# Nos t√¢ches longue dur√©e
tache_a = fn -> Process.sleep(2000); "Op√©ration 1 termin√©e" end
tache_b = fn -> Process.sleep(2000); "Op√©ration 2 termin√©e" end
```

```elixir
# ex√©cution synchrone

temps_depart_ms = System.monotonic_time(:millisecond)

tache_a.()
tache_b.()

duree_ms = System.monotonic_time(:millisecond) - temps_depart_ms
IO.puts "Dur√©e d'ex√©cution: #{duree_ms}ms"
```

```elixir
# ex√©cution concurrente
temps_depart_ms = System.monotonic_time(:millisecond)

# Lancement des t√¢ches
task1 = Task.async(tache_a)
task2 = Task.async(tache_b)

# Attente des r√©sultats
Task.await_many([task1, task2])

duree_ms = System.monotonic_time(:millisecond) - temps_depart_ms
IO.puts "Dur√©e d'ex√©cution: #{duree_ms}ms"
```

On comprend imm√©diatement l'int√©r√™t de la seconde approche: le temps d'ex√©cution n'est plus la somme des temps individuels des diff√©rents t√¢ches, mais devient (√† quelques ms pr√®s) la dur√©e de la t√¢che la plus longue.

On peut l'illustrer par le sch√©ma:

<!-- livebook:{"break_markdown":true} -->

```mermaid
gantt
    dateFormat  ss
    axisFormat  %Ss
    section S√©quentiel
    T√¢che_A :done, seq1, 00, 2s
    T√¢che_B :done, seq2, after seq1, 2s
    section Parall√®le
    T√¢che_A :done, par1, 00, 2s
    T√¢che_B :done, par2, 00, 2s
```

<!-- livebook:{"branch_parent_index":0} -->

## Faire des requ√™tes HTTP (internet) avec Elixir

<!-- livebook:{"attrs":"eyJxdWVyaWVzIjpbeyJhdXRoIjp7InNjaGVtZSI6Im5vbmUiLCJ0eXBlIjowLCJ2YWx1ZSI6IiJ9LCJib2R5Ijp7ImNvbnRlbnRUeXBlIjoibm9uZSIsImZvcm0iOltdLCJyYXciOiIifSwiaGVhZGVycyI6W10sIm9wdGlvbnMiOnsiY29udGVudFR5cGUiOiJlbGl4aXIiLCJyYXciOiIifSwicGFyYW1zIjpbXSwicGx1Z2lucyI6W3siYWN0aXZlIjpmYWxzZSwiZGVzY3JpcHRpb24iOiJBIGNvbGxlY3Rpb24gb2Ygc3RlcHMsIHVzYWJsZSB3aXRoIFJlcS4iLCJuYW1lIjoiQ3VybFJlcS5QbHVnaW4iLCJ2ZXJzaW9uIjpudWxsfV0sInJlcXVlc3RfdHlwZSI6ImdldCIsInN0ZXBzIjp7ImVycm9yX3N0ZXBzIjpbeyJhY3RpdmUiOnRydWUsImRvYyI6IlJldHJpZXMgYSByZXF1ZXN0IGluIGZhY2Ugb2YgZXJyb3JzLiIsIm5hbWUiOiJyZXRyeSJ9XSwicmVxdWVzdF9zdGVwcyI6W3siYWN0aXZlIjp0cnVlLCJkb2MiOiJTZXRzIHRoZSB1c2VyLWFnZW50IGhlYWRlci4iLCJuYW1lIjoicHV0X3VzZXJfYWdlbnQifSx7ImFjdGl2ZSI6dHJ1ZSwiZG9jIjoiQXNrcyB0aGUgc2VydmVyIHRvIHJldHVybiBjb21wcmVzc2VkIHJlc3BvbnNlLiIsIm5hbWUiOiJjb21wcmVzc2VkIn0seyJhY3RpdmUiOnRydWUsImRvYyI6IkVuY29kZXMgdGhlIHJlcXVlc3QgYm9keS4iLCJuYW1lIjoiZW5jb2RlX2JvZHkifSx7ImFjdGl2ZSI6dHJ1ZSwiZG9jIjoiU2V0cyBiYXNlIFVSTCBmb3IgYWxsIHJlcXVlc3RzLiIsIm5hbWUiOiJwdXRfYmFzZV91cmwifSx7ImFjdGl2ZSI6dHJ1ZSwiZG9jIjoiU2V0cyByZXF1ZXN0IGF1dGhlbnRpY2F0aW9uLiIsIm5hbWUiOiJhdXRoIn0seyJhY3RpdmUiOnRydWUsImRvYyI6IkFkZHMgcGFyYW1zIHRvIHJlcXVlc3QgcXVlcnkgc3RyaW5nLiIsIm5hbWUiOiJwdXRfcGFyYW1zIn0seyJhY3RpdmUiOnRydWUsImRvYyI6IlVzZXMgYSB0ZW1wbGF0ZWQgcmVxdWVzdCBwYXRoLiIsIm5hbWUiOiJwdXRfcGF0aF9wYXJhbXMifSx7ImFjdGl2ZSI6dHJ1ZSwiZG9jIjoiU2V0cyB0aGUgXCJSYW5nZVwiIHJlcXVlc3QgaGVhZGVyLiIsIm5hbWUiOiJwdXRfcmFuZ2UifSx7ImFjdGl2ZSI6dHJ1ZSwiZG9jIjoiUGVyZm9ybXMgSFRUUCBjYWNoaW5nIHVzaW5nIGBpZi1tb2RpZmllZC1zaW5jZWAgaGVhZGVyLiIsIm5hbWUiOiJjYWNoZSJ9LHsiYWN0aXZlIjp0cnVlLCJkb2MiOiJTZXRzIGFkYXB0ZXIgdG8gYHJ1bl9wbHVnLzFgLiIsIm5hbWUiOiJwdXRfcGx1ZyJ9LHsiYWN0aXZlIjp0cnVlLCJkb2MiOiJDb21wcmVzc2VzIHRoZSByZXF1ZXN0IGJvZHkuIiwibmFtZSI6ImNvbXByZXNzX2JvZHkifSx7ImFjdGl2ZSI6dHJ1ZSwiZG9jIjoiU2V0cyBleHBlY3RlZCByZXNwb25zZSBib2R5IGNoZWNrc3VtLiIsIm5hbWUiOiJjaGVja3N1bSJ9LHsiYWN0aXZlIjp0cnVlLCJkb2MiOiJTaWducyByZXF1ZXN0IHdpdGggQVdTIFNpZ25hdHVyZSBWZXJzaW9uIDQuIiwibmFtZSI6InB1dF9hd3Nfc2lndjQifV0sInJlc3BvbnNlX3N0ZXBzIjpbeyJhY3RpdmUiOnRydWUsImRvYyI6IlJldHJpZXMgYSByZXF1ZXN0IGluIGZhY2Ugb2YgZXJyb3JzLiIsIm5hbWUiOiJyZXRyeSJ9LHsiYWN0aXZlIjp0cnVlLCJkb2MiOiJIYW5kbGVzIEhUVFAgNHh4LzV4eCBlcnJvciByZXNwb25zZXMuIiwibmFtZSI6ImhhbmRsZV9odHRwX2Vycm9ycyJ9LHsiYWN0aXZlIjp0cnVlLCJkb2MiOiJGb2xsb3dzIHJlZGlyZWN0cy4iLCJuYW1lIjoicmVkaXJlY3QifSx7ImFjdGl2ZSI6dHJ1ZSwiZG9jIjoiRGVjb21wcmVzc2VzIHRoZSByZXNwb25zZSBib2R5IGJhc2VkIG9uIHRoZSBgY29udGVudC1lbmNvZGluZ2AgaGVhZGVyLiIsIm5hbWUiOiJkZWNvbXByZXNzX2JvZHkifSx7ImFjdGl2ZSI6dHJ1ZSwiZG9jIjoiVmVyaWZpZXMgdGhlIHJlc3BvbnNlIGJvZHkgY2hlY2tzdW0uIiwibmFtZSI6InZlcmlmeV9jaGVja3N1bSJ9LHsiYWN0aXZlIjp0cnVlLCJkb2MiOiJEZWNvZGVzIHJlc3BvbnNlIGJvZHkgYmFzZWQgb24gdGhlIGRldGVjdGVkIGZvcm1hdC4iLCJuYW1lIjoiZGVjb2RlX2JvZHkifSx7ImFjdGl2ZSI6dHJ1ZSwiZG9jIjpudWxsLCJuYW1lIjoib3V0cHV0In1dfSwidXJsIjoiaHR0cHM6Ly9wb2tlYXBpLmNvL2FwaS92Mi9wb2tlbW9uL3Bpa2FjaHUiLCJ2YXJpYWJsZSI6InJlc3AiLCJ2ZXJicyI6WyJnZXQiLCJwb3N0IiwicHV0IiwicGF0Y2giLCJkZWxldGUiLCJoZWFkIiwib3B0aW9ucyJdfV0sInF1ZXJ5SW5kZXgiOjB9","chunks":null,"kind":"Elixir.Merquery.SmartCell","livebook_object":"smart_cell"} -->

```elixir
req =
  Req.new(
    method: :get,
    url: "https://pokeapi.co/api/v2/pokemon/pikachu",
    headers: %{},
    params: %{}
  )
{req, resp} = Req.request(req)
resp
```

```elixir

```
