# Elixir pour de vrai

```elixir
Mix.install([
  {:kino, "~> 0.16.1"},
  {:pythonx, "~> 0.4.2"},
  {:kino_pythonx, "~> 0.1.0"}
])
```

```pyproject.toml
[project]
name = "project"
version = "0.0.0"
requires-python = "==3.13.*"
dependencies = []
```

## Introduction

Dans le notebook pr√©c√©dent, nous nous √©tions concentr√©s sur les caract√©ristiques communes √† Elixir et Python, afin de vous accompagner dans la transition d'un langage vers l'autre.

√âvidemment cette comparaison a ses limites: si les deux langages √©taient totalement √©quivalents, nous ne serions pas en train d'apprendre Elixir !

Ce nouveau Notebook a deux objectifs:

- explorer les bases du langage d'une fa√ßon plus approfondie: lister les diff√©rents types, d√©couvrir les conteneurs de donn√©es (listes, etc.)
- commencer √† illustrer les diff√©rences ‚Äì syntaxiques mais pas que ‚Äì entre Elixir et Python, afin de vous rendre plus efficaces dans votre pratique de la programmation

<!-- livebook:{"branch_parent_index":0} -->

## Les types de base

Tous les langages de programmation, quels qu'ils soient, proposent un certain nombre de type de donn√©es qu'ils peuvent manipuler : cha√Ænes de caract√®res, nombre, tableaux etc.

Elixir ne fait pas exception, et le but de cette section est donc de vous pr√©senter ces types, dont certains vous seront familiers, et d'autres constitueront une nouveaut√©.

<!-- livebook:{"break_markdown":true} -->

### Les types num√©riques

Comme √©voqu√© dans notre pr√©c√©dent notebook, Elixir propose deux types destin√©s √† stocker des valeurs num√©riques:

- le type `integer` correspont √† des _entiers 64 bits_
- le type `float` correspond √† de nombre √† _virgule flottant 64 bits_ (dits aussi "double pr√©cision")

Il est possible de tester tr√®s facilement le type d'une valeur ‚Äì ou d'une variable ‚Äì via des fonctions d√©di√©es:

```elixir
is_float(3.14)
```

```elixir
is_integer(42)
```

```elixir
# Fonctionne avec les integer ou les floats
IO.puts( is_number(3.14) )
IO.puts( is_number(42) )
```

Elixir supporte √©galement diff√©rents formats de saisie pour ces valeurs, telles que:

- la notation avec exposant pour les flottants:
  ```elixir
  1.0e10 # üëâ 10000000000.0
  ```
- la notation avec des s√©parateurs "\_" pour les longs entiers (ou flottants)
  ```elixir
  1_000_000_000    # üëâ 1000000000
  1_000_000_000.42 # üëâ 1000000000.42
  ```
- les notations binaires, octales (base 8) ou hexad√©cimale (base 16) pour les entiers:
  ```elixir
  0b110011 # üëâ 52  (en binaire)
  0o444    # üëâ 292 (en octal)
  0xff     # üëâ 255 (en hexa)
  ```

<!-- livebook:{"break_markdown":true} -->

Toutes les **op√©rations** arithm√©tiques classiques sont support√©es:

- la multiplication avec `*`
- la division avec `/`
- l'addition avec `+`
- la soustraction avec `-`

De plus, Elixir supporte l'op√©rateur d'exponentiation `**` comme Python.

<!-- livebook:{"break_markdown":true} -->

#### Autres fonctions math√©matiques

Elixir est g√©n√©ralement moins bien √©quip√© que Python en ce qui concerne le calcul math√©matique: en effet, le focus du langage (les syt√®mes distribut√©s) n'est pas le m√™me que celui de Python et cela se ressent au niveau des fonctions disponibles.

Tout n'est pas pas perdu cependant !
Il existe en effet deux solutions pour manipuler des objets math√©matiques en Elixir:

1. utiliser les fonctionnalit√©s issues de Erlang, et en particulier son module `:math` qui donne les principales fonctions usuelles, par ex. les fonctions trigonom√©triques
2. utiliser [`Nx`, qui est "le numpy d'Elixir"](https://github.com/elixir-nx/nx/tree/main/nx#readme) et que nous aborderons plus tard dans ce cours

<!-- livebook:{"break_markdown":true} -->

Voici un exemple d'utilisation du module `:math` d'Erlang, vous remarquerez tout de suite que la "syntaxe d'appel est diff√©rente".

En effet: le nom du module Erlang est un "atome" Elixir ‚Äì une notion que nous aborderons plus loin dans ce cours ‚Äì commen√ßant par `:`. C'est cette diff√©rence qui nous permet de diff√©rencier les appels √† la "librairie standard Elixir" des appels au sous-syst√®me Erlang.

Vous pouvez donc √©valuer la cellule suivante:

```elixir
:math.cos(44)
```

ce qui est √©quivalent, en Erlang (ici pour votre culture, pas la peine de m√©moriser √ßa !) √†:

```erlang
math:cos(44).
```

### Les atomes

Nous les avons √©voqu√©s √† plusieurs reprises, il est temps de d√©finir ce qu'est un atome: c'est une **constante nomm√©e** du langage.

_Qu'est-ce que √ßa peut bien vouloir dire ?_

Il est parfois n√©cessaire, dans un programme, de d√©finir certaines constantes pour qualifier des valeurs particuli√®res:

- la constante `true` (√©quivalente au `True` Python) quand un test est vrai
- la constante `false` (√©quivalente au `False` Python) quand un test est faux
- la constante `nil` (√©quivalente au `None` Python) et qui marque une absence de valeur

toutes ces constantes sont appel√©es des atomes en Elixir:

```elixir
is_atom(true)
```

```elixir
is_atom(false)
```

```elixir
is_atom(nil)
```

La diff√©rence avec Python, c'est qu'Elixir nous permet de d√©finir nos _propres constantes_ pour qualifier certaines valeurs de nos programmes.

Typiquement, les fonctions d'Elixir ‚Äì comme `IO.puts/1` que nous avons d√©j√† rencontr√©e ‚Äì renvoient souvent `:ok` en cas de succ√®s. Cette constant `:ok` est un atome:

```elixir
is_atom(:ok)
```

et vous pouvez facilement d√©finir vos propres atomes: il suffit de nommer la constante en commen√ßant par `:` suivi d'une suite de lettres contig√ºes, √©ventuellement s√©par√©es par des `_`:

```elixir
:je_suis_un_atome
:moi_aussi
:idem
```

_Quel est l'int√©r√™t de ce nouveau type ?_

L'int√©r√™t de ce type est multiple:

- d√©finir des "valeurs de r√©f√©rence" qui ont un r√¥le particulier dans mon programme: pensez √† l'atome `:ok` que nous avons √©voqu√© et qui marque le succ√®s d'un appel de fonction. De la m√™me fa√ßon de nombreuses fonctions renvoient `:error` en cas d'erreur
- par rapport √† utiliser une cha√Æne de caract√®res comme on le ferait en Python, on gagne en perfomance: en effet Elixir garantit que chaque atome identique (par ex. "tous les `:ok`) pointent vers la m√™me adresse m√©moire, rendant ainsi la comparaison tr√®s rapide

<!-- livebook:{"break_markdown":true} -->

#### Autre types d'atomes

Il existe √©galement d'autres types d'atomes:

- tous les noms de modules elixir sont des atomes
- on peut cr√©er des atomes avec des espaces ou d'autres caract√®res en utilisant la syntaxe: `:"un atome avec des espaces"`

```elixir
# le nom du module IO est un atome
is_atom(IO)
```

```elixir
# c'est √©galement valable pour les modules "emboit√©s" (dont nous parlerons plus tard)
defmodule RootModule do
  defmodule NestedModule do
  end
end

is_atom(RootModule.NestedModule)
```

```elixir
is_atom( :"atome avec des espaces et des emojis üöÄ" )
```

<!-- livebook:{"branch_parent_index":0} -->

## Les conteneurs: bases

Elixir dispose d'une biblioth√®que de conteneurs, tr√®s semblables √† ceux dont on dispose en Python.
Comme √† l'accoutum√©e dans ce cours, nous travaillerons en mettant en parall√®le les deux langages afin de faciliter la compr√©hension des notions expos√©es.

<!-- livebook:{"break_markdown":true} -->

### Les tuples

Il s'agit d'un groupement de valeurs, √©ventuellement de natures diff√©rentes. Pour rappel, voici la fa√ßon dont les tuples se d√©clarent en Python:

```python
my_tuple = (1, "a", 3.14)
print(f"{my_tuple=}")

# affichage des diff√©rentes valeurs
print(f"{my_tuple[0]=}")
print(f"{my_tuple[1]=}")
print(f"{my_tuple[2]=}")
```

En Elixir, la syntaxe est subtilement diff√©rente:

- on utilisera des crochets `{` et `}` )plut√¥t que les parenth√®ses utilis√©es en Python)
- [l'operateur `elem`](https://hexdocs.pm/elixir/1.18.3/Kernel.html#elem/2) permet de r√©cup√©rer la valeur disponible √† un index donn√©

```elixir
my_tuple = {1, "a", 3.14}
IO.inspect(my_tuple, label: "my_tuple")

IO.puts("Valeurs contenues dans le tuple:")
IO.inspect( elem(my_tuple, 0) )
IO.inspect( elem(my_tuple, 1) )
IO.inspect( elem(my_tuple, 2) )
```

üí° Elixir propose √©galement une syntaxe dite de "pattern matching" que nous explorerons ensemble plus tard dans ce notebook.

<!-- livebook:{"break_markdown":true} -->

### Les listes

Il s'agit probablement du conteneur qui est le plus diff√©rent entre Python en Elixir, et ce pour une bonne raison:

- les "listes Python" ne sont pas des listes ! Le type `list` de Python, que vous connaissez, contient en r√©alit√© un tableau de valeurs contigues en m√©moire
- le type "liste" d'Elixir (d'Erlang en r√©alit√©) repr√©sente une v√©ritable liste cha√Æn√©e, c'est-√†-dire une structure de donn√©es o√π les valeurs sont reli√©es entre elles par des "pointeurs" en m√©moire
- la liste Elixir est immutable, comme tout ce qui est en m√©moire en Elixir d'ailleurs

Tout cela doit vous sembler _bien abstrait pour l'instant_ mais nous allons illustrer ces concepts et ils feront sens.

<!-- livebook:{"break_markdown":true} -->

#### La liste Elixir est une liste cha√Æn√©e

Commen√ßons par d√©finir une liste Elixir tr√®s simple: ce ne sera pas difficile vu que la syntaxe _est la m√™me qu'en Python_:

```python
# Version Python
my_list = [1, 2, 3, 4]
my_list
```

<!-- livebook:{"break_markdown":true} -->

en python, nous aurions une liste d'√©l√©ments contig√ºe en m√©moire:

```mermaid
block-beta
    l>"my_list"]
    block:B
        1 2 3 4
    end
    l-->B
```

```elixir
# Version Elixir
my_list = [1, 2, 3, 4]
```

Cette fois-ci, nous avons cr√©√© une s√©quence d'objets en m√©moire qui se r√©f√©rencent les uns les autres:

```mermaid
block-beta
    l>"my_list"]
    block:B
        aa["1"]
        block:C
            bb["2"]
            block:D
                cc["3"]
                dd["4"]
                cc-->dd
            end
            bb-->D
        end
        aa-->C
    end
    l-->B
```

la liste `[1, 2, 3, 4]` est compos√©e en m√©roire:

- de la valeur `1`, suivie de la liste `[2, 3, 4]`
- la valeur `[2, 3, 4]` est elle-m√™me compos√©e de la valeur `2`, suivie de la liste `[3, 4]`
- la valeur `[3, 4]` est elle-m√™me compos√©e de la valeur `3`, suivie de la liste `[4]`
- qui est elle-m√™me compos√©e de la valeur `4` sans liste suivante (`nil`)

<!-- livebook:{"break_markdown":true} -->

on peut d'ailleurs reconstituer notre liste gr√¢ce √† l'op√©rateur `|` qui permet d'ajouter une valeur au d√©but d'une liste:

```elixir
# on part d'une liste vide
l_vide = []
dbg(l_vide)

# on lui ajoute la valeur "4" au d√©but
l_une_valeur = [ 4 | l_vide ]
dbg(l_une_valeur)

# on ajoute "3" au d√©but de la liste suivante
l_deux_valeurs = [ 3 | l_une_valeur ]
dbg(l_deux_valeurs)

# etc. etc.
[
  1 | [
    2 | l_deux_valeurs
  ]
]
```

De cette construction d√©coule un profil de perfomance tr√®s diff√©rent entre Elixir et Python:

- en Elixir, il est **rapide** d'ajouter en d√©but de liste et **lent** d'ajouter √† la fin de la liste
- en Python c'est l'inverse !
- en Elixir il est rapide de **parcourir** la liste dans l'ordre mais lent d'acc√©der √† un √©l√©ment quelconque par son indice
- en Python les deux sont perfomants ("random access")

Mais alors, _pourquoi utilise-t-on cette approche compliqu√©e dans les structures de donn√©es en Elixir_ ?

L'explication se trouve ‚Äì en partie ‚Äì dans le paragraphe suivant:

<!-- livebook:{"break_markdown":true} -->

#### Caract√®re immutable de la m√©moire en Elixir

Une des diff√©rences principales entre Elixir et Python, c'est qu'on ne peut pas modifier les valeurs qui ont √©t√© mises en m√©moire.
En effet, on peut _r√©-assigner_ une variable dans notre code, mais la valeur en m√©moire que r√©f√©rence cette variable n'est pas modifiable.

Prenons, encore une fois, un exemple en Python pour comparer:

```python
# une liste Python d'exemple
l = [1, 2, 3, 4]
l[1] = 44 # üëà on modifie notre liste
l
```

Dans cet exemple, nous avons cr√©√© une liste en m√©moire et l'avons modifi√©e, rien de spectaculaire.

R√©-√©crions cet exemple en Elixir:

```elixir
l = [1, 2, 3, 4]
List.replace_at(l, 1, 44)
l
```

Nous constatons que _la valeur de `l` n'a pas chang√©_ !

En effet, une fois d√©finir en m√©moire, il n'est pas possible de modifier la valeur de cette liste.

Mais alors _qu'a bien pu faire l'appel √† `List.replace_at/3`_ ?

En r√©alit√©, cet appel n'a pas modifi√© notre liste, mais a cr√©√© une nouvelle liste qui reprend les valeurs de la liste pr√©c√©dente et modifie uniquement la valeur de rang 1. Pour que notre code fonctionne, nous aurions donc d√ª r√©-assigner la variable `l` avec le _r√©sultat_ de l'appel √† `replace_at` comme suit (concentrez-vous, le changement est subtil !):

```elixir
l = [1, 2, 3, 4]
l = List.replace_at(l, 1, 44)
l
```

Cette approche pr√©sente plusieurs avantages, et s'int√©gre bien avec les structures de donn√©es pr√©sentes dans Elixir:

- le c√¥t√© immutable simplifie √©norm√©ment le fonctionnement "concurrent" du code: beaucoup de bugs des syst√®mes dits "parall√®les" sont d√ªs √† des acc√®s concurrents √† la m√©moire, c-√†-d. quand une partie du programme essaye de lire une information qu'une autre partie du programme essaye de modifier en m√™me temps. En rendant la memoire non-modifiable, Elixir √©limine toute une cat√©gorie de bugs potentiels
- les listes cha√Æn√©es utilis√©es par Elixir permettent de r√©-utiliser une partie des donn√©es lors des modifications. En effet, comme la m√©moire n'est jamais modifi√©e il n'y a aucun risque √† r√©f√©rencer une partie d'une autre liste dans une nouvelle liste afin d'√©conomiser de la m√©moire.

Dans le cas pr√©sent√© ci-desssu, lorsqu'on modifie le deuxi√®me √©l√©ment, la fin de la liste (`[3, 4]`) pourra √™tre r√©-utilis√©e comme fin de la nouvelle liste modifi√©e:

```mermaid
block-beta
columns 2
    l>"my_list"]
    block:B
        aa["1"]
        block:C
            bb["2"]
            block:D
                cc["3"]
                dd["4"]
                cc-->dd
            end
            bb-->D
        end
        aa-->C
    end
    block:XB
        Xaa["1"]
        block:XC
            Xbb["44"]
            Xbb-->D
        end
        Xaa-->XC
    end
    l-->XB
```

<!-- livebook:{"break_markdown":true} -->

### Les tableaux associatifs

Ce sont l'√©quivalent des `dict` Python, et leur syntaxe est tr√®s diff√©rente: voici ci-dessous un exemple en Python et un exemple √©quivalent en Elixir (j'ai cherch√© un nom de mineur typique ü§∑).

<!-- livebook:{"break_markdown":true} -->

en Python:

```python
# Rappel: un dictionnaire Python
gonzague = {
  "prenom": "Gonzague",
  "nom": "de Saint-Louis",
  "age": 20
}

print( f"l'√©l√®ve {gonzague["prenom"]} {gonzague["nom"]} a {gonzague["age"]} ans" )
```

en Elixir:

```elixir
# avec un dictionnaire Elixir
gonzague = %{
  "prenom" => "Gonzague",
  "nom" => "de Saint-Louis",
  "age" => 20
}

IO.puts( "l'√©l√®ve #{gonzague["prenom"]} #{gonzague["nom"]} a #{gonzague["age"]} ans" )
```

Les diff√©rences syntaxiques sont donc les suivantes:

- on utilise les d√©limiteurs `%{` et `}` pour encadrer le tableau associatif (et non `{` et `}` comme en Python, qui en Elixir sont utilis√©s _pour les tuples_)
- on s√©pare les cl√©s des valeurs avec la "fl√®che" `=>`

<!-- livebook:{"break_markdown":true} -->

Il existe √©galement des **raccourcis syntaxiques** au cas o√π l'on **utilise des atomes en guise de cl√©s**, d√©monstration:

```elixir
gonzague = %{
  prenom: "Gonzague",
  nom: "de Saint-Louis",
  age: 20
}

"l'√©l√®ve #{gonzague.prenom} #{gonzague.nom} a #{gonzague.age} ans"
```

on remarque alors que:

- les cl√©s sont √©crites avec "le `:` coll√© √† la fin. Cette syntaxe est en fait √©quivalente √† √©crire:
  ```elixir
  %{
    :prenom => "Gonzague",
    :nom => "de Saint-Louis",
    :age => 20
  }
  ```
- on acc√®de aux diff√©rentes valeurs avec une syntaxe `.` qui est √©galement un raccourci:
  ```elixir
  gonzague.prenom
  ```
  est √©quivalent √†
  ```elixir
  gonzague[:prenom]
  ```

<!-- livebook:{"break_markdown":true} -->

#### Bonus: syntaxe de mise √† jour

Il existe une syntaxe sp√©cifique pour mettre √† jour les champs d'une [Map Elixir](https://hexdocs.pm/elixir/Map.html): il suffit de:

- cr√©er un bloc entre `%{` et `}`
- mettre en premier la valeur pr√©c√©dente
- puis le symbole `|`
- puis les cl√©s/valeurs √† mettre √† jour

exemple:

```elixir
ernest = %{
  # Ernest a tous les champs de gonzague, √† l'exception du pr√©nom
  gonzague | prenom: "Ernest"
}
```

<!-- livebook:{"branch_parent_index":0} -->

## Pattern-matching simple

Une des principales caract√©ristiques d'Elixir, en tant que langage, est la pr√©valence de la notion de "pattern matching" dans le langage. Nous allons commencer √† explorer cette notion, √† travers des exemples simples puis de plus en plus complexes.

#### Op√©rateur `=`

Nous avons vu plus t√¥t que nous pouvions assigner une variable avec une syntaxe identique √† celle de Python:

```elixir
number_of_the_beast = 666
```

Ce que nous n'avons **pas** √©voqu√© par contre, c'est que l'op√©rateur `=` d'Elixir n'est pas un _op√©rateur d'assignation_ mais un _op√©rateur de "matching"_: il essaye de vaire correspondre son membre de gauche avec son membre de droite.
Dans notre cas ci-dessus:

- √† gauche nous avions la variable `number_of_the_beast`
- √† droite le nombre `666`

et il a assign√© la valeur √† la variable pour satisfaire l'√©galit√©.

<!-- livebook:{"break_markdown":true} -->

mais nous aurions parfaitement pu √©crire (ce qui n'aurait aucun sens en Python):

```elixir
666 = 666
```

l√† o√π cette syntaxe devient plus int√©ressante, c'est lorsqu'on a une des valeurs plus complexes (des conteneurs typiquement) √† gauche et √† droite, par ex. un tuple:

```elixir
{a, b, c} = {1, 2, 3}

dbg(a)
dbg(b)
dbg(c)
```

si vous avez bien suivi vos cours de Python, vous devriez me r√©torque qu'on peut faire √† peu pr√®s la m√™me chose en Python:

```python
(a, b, c) = (1, 2, 3)

print(f"{a=}")
print(f"{b=}")
print(f"{c=}")
```

mais Elixir pousse le concept beaucoup plus loin:

- on peut avoir non seulement des variables mais aussi des valeurs √† gauche
- on peut √©galement mapper des dictionnaires

exemples:

```elixir
# avec un Tuple
{1, a, 2} = {1, 44, 2}
dbg(a)

# avec une liste
[3, c, d] = [3, 4, 5]
dbg(c)
dbg(d)

# avec un dictionnaire
%{
  "nom" => nom,
  "prenom" => prenom
} = %{
  "nom" => "Smith",
  "prenom" => "John"
}
dbg(prenom)
dbg(nom)
```

#### Pattern matching sur les listes chain√©es

Il est possible de faire du pattern-matching en utilisant l'op√©rateur `|` sur les listes:

```elixir
ex_list = [1, 2, 3, 4]

[a | rest] = ex_list
dbg(a)
dbg(rest)
```

<!-- livebook:{"branch_parent_index":0} -->

## (Quelques) Structure conditionnelles

Nous avons tenu jusqu'ici sans √©voquer le `if`, c'est un exploit ü§£

Il est temps de vous pr√©senter les structures conditionnelles en Elixir: certaines sont connues, d'autres vous surprendrons. Dans tous les cas, vous devriez avoir absorb√© suffisemment d'√©l√©ments de syntaxe pour comprendre les exemples suivants.

<!-- livebook:{"break_markdown":true} -->

### Le `if` (et son cousin `unless`)

Comme la plupart des langages, Elixir dispose d'une structure de contr√¥le `if`. Sa syntaxe est proche de celle de Python, avec comme diff√©rence principale la pr√©sence de blocs d√©finis entre `do` et `end`:

```elixir
# faites varier la valeur de a
a = 100

if a > 10 do
  IO.puts "a est grand"
  true # valeur retourn√©e par le if = derni√®re expression de ce bloc
else
  IO.puts "a est petit"
  false # valeur retourn√©e par le else = derni√®re expression de ce bloc
end
```

üí° Vous remarquerez que le `if` retourne toujours une valeur, qui est la valeur de la derni√®re expression √©valu√©e dans le bloc. Il est donc possible de r√©cup√©rer cette valeur dans une variable:

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
was_big = if a > 10 do
  true
else
  false
end

dbg(was_big)
```

comme √©voqu√© il existe une construction `unless` qui est √©quivalent √† un "`if` not":

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
unless a <= 10 do
  IO.puts "a n'est pas petit"
else
  IO.puts "a n'est pas pas petit"
end
```

### Le `cond`

Le `cond` est la construction Elixir qui remplace le `elif` de Python: elle permet d'encha√Æner les tests les uns apr√®s les autres, jusqu'√† qu'une des branches soit vraie.

Soit une valeur de r√©f√©rence:

```elixir
a = 60
```

Partons d'un exemple en Python:

<!-- livebook:{"reevaluate_automatically":true} -->

```python
if a < 10:
  print("a est tout petit")
elif a < 50:
  print("a est de taille moyenne")
elif a < 90:
  print("a est de grande taille")
else:
  print("a est de immense")
```

nous pouvons le r√©-√©cire en Elixir comme suit:

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
cond do
  a < 10 ->
    "a est tout petit"

  a < 50 ->
    "a est de taille moyenne"

  a < 90 ->
    "a est de grande taille"

  # une condition finale √† "true" (toujours vraie) tient lieu de "else"
  true ->
    "a est immense"
end
```

on remarque donc la syntaxe du cond:

- il s'agit d'une s√©rie de sous-blocs (eux m√™me √† l'int√©rieur du bloc `do`...`end`)
- chaque expression commence par une condition (`a < 10`, `a < 50` etc.)
- suivie d'une fl√®che `->`
- suivie du code √† √©valuer dans le cas o√π la condition renvoie `true`

_vous pouvez faire varier la valeur de r√©f√©rence afin d'observer les changements et de confirmer un comportement identique √† celui de Python_

<!-- livebook:{"break_markdown":true} -->

### Le `case`

Une autre construction int√©ressante est le `case` qui est semblable au `switch` que l'on trouve dans certains langages de programmation (mais pas en Python). Cette construction permet de comparer une unique valeur √† une s√©rie de valeur possible, tout en faisant du pattern-matching:

```elixir
case a do
  # uniquement si a == 0
  0 ->
    "a est nul"

  # on r√©cup√®re la valeur de a dans la variable local "val"
  val ->
    "a vaut #{val}"
end
```

cette construction n'a pas l'air tr√®s puissante en soi, mais sa capacit√© √† faire du pattern-matching la rend tr√®s puissante, par ex.:

```elixir
# faites varier tab !
tab = [ 1, 2, 3 ]

case tab do
  # si tab est une liste de 3 √©l√©ments qui commence par 1 et se termine par 3
  [ 1, x, 3 ] ->
    "x vaut #{x}"

  # si tab est une autre liste de 3 elements
  [ a, b, c] ->
    a + b + c

  # dans tous les autres cas (`_` est une variable "poubelle")
  _ ->
    "pas le format attendu !"
end
```
