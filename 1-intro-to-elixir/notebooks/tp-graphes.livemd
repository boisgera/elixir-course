# C1TP – Parcours d’un labyrinthe

```elixir
Mix.install([
  {:kino, "~> 0.16.1"},
  {:phoenix_live_view, "~> 1.1"}
])

ExUnit.configure(exclude: [:skip])
ExUnit.start(autorun: false)
```

## Objectif(s)

* Manipuler les **listes** et **maps**.
* Implémenter un **algorithme simple** (parcours en largeur ou profondeur).
* Découvrir une représentation **graphique / automate** d’un problème.
* Écrire et composer des **fonctions**.

## 1. Représenter un graphe

### Qu’est-ce qu’un graphe ?

Un **graphe** $G = (V, E)$ est un couple constitué :

* d’un ensemble $V$ de **sommets** (ou nœuds),
* d’un ensemble $E \subseteq \{ \{u, v\} \mid u, v \in V, u \ne v \}$ de **paires non ordonnées** appelées **arêtes** (ou liens).

On parle alors de **graphe non orienté** et **simple** (sans boucles ni arêtes multiples).

#### Exemple :

$$
V = \{A, B, C, D\}, \quad E = \{\{A,B\}, \{A,D\}, \{B,C\}, \{C,D\} \}
$$

correspond au graphe suivant:

```mermaid
graph LR
  A --- B
  A --- D
  B --- C
  C --- D
```

<!-- livebook:{"break_markdown":true} -->

### Représentation informatique du graphe

Il existe beaucoup de manière de représenter un graphe.
On peut le représenter par une **carte** (graphe dessiné, voir ci-dessous), par un ensemble de "noeuds" dans la mémoire de l'ordinateur, par une **liste d’adjacence**, ou encore une **matrice d’adjacence**.

Dans ce TP, nous utilisons la **liste d’adjacence**, qui consiste à associer à chaque noeud du graphe la liste des noeuds qui le suivent.

Toujous sur notre exemple, cela donnerait:

```elixir
graphe_simple = %{
  "A": [ "B", "D" ], # Les "successeurs de A sont B et D
  "B": [ "C" ],      # Le successeur de B est D
  "C": [ "D" ],      # Le successeur de C est D
}
```

### Un graphe plus complet

On considère un petit comme celui-ci pour représenter notre labyrinthe :

```mermaid
graph LR
  classDef start fill:#dff,stroke:#06c,stroke-width:2px;
  classDef goal  fill:#ffd,stroke:#c60,stroke-width:2px;

  A:::start <--> B <--> C
  A <--> D
  B <--> E
  D <--> E <--> F:::goal
  C <--> F
```

<!-- livebook:{"break_markdown":true} -->

On peut le représenter par une **liste d’adjacence** :

```elixir
graph = %{
  "A" => ["B", "D"],
  "B" => ["A", "C", "E"],
  "C" => ["B", "F"],
  "D" => ["A", "E"],
  "E" => ["B", "D", "F"],
  "F" => ["C", "E"]
}

%{ "A" => ["B", "D"], "B" => ["A", "C", "E"], "C" => ["B", "F"], "D" => ["A", "E"], "E" => ["B", "D", "F"], "F" => ["C", "E"] }
```

💡 _on remarquera que dans ce cas, le graphe n'est pas "orienté": s'il est permis d'aller de $A$ vers $B$, alors ils est permis d'aller de $B$ vers $A$_

<!-- livebook:{"break_markdown":true} -->

### Écrire une fonction `GraphInfo.neighbors/2` qui renvoie la liste des voisins d’un nœud.

⚠️ Dans le cas où aucune arrête n'est spécifiée pour un noeud, on renverra une liste vide `[]`

💡 Pensez à consulter la [documentation du module `Map`](https://hexdocs.pm/elixir/Map.html) au besoin

```elixir
defmodule GraphInfo do

  @doc """
    iex> graph = %{ "A" => ["B", "D"], "B" => ["A", "C", "E"] }
    iex> GraphInfo.neighbors(graph, "A")
    ["B", "D"]

    iex> graph = %{ "A" => ["B", "D"], "B" => ["A", "C", "E"] }
    iex> GraphInfo.neighbors(graph, "C")
    []

  """
  def neighbors(graph, node) do
    []
  end
  
end
```

```elixir
# CORRECTION POSSIBLE

defmodule GraphInfoCorrige do

  @doc """
    iex> graph = %{ "A" => ["B", "D"], "B" => ["A", "C", "E"] }
    iex> GraphInfoCorrige.neighbors(graph, "A")
    ["B", "D"]
    
    iex> graph = %{ "A" => ["B", "D"], "B" => ["A", "C", "E"] }
    iex> GraphInfo.neighbors(graph, "C")
    []
  """
  def neighbors(graph, node) do
    Map.get(graph, node, [])
  end
  
end
```

## 2. Parcours en largeur (BFS)

Nous voulons désormais parcourir notre graphe "en largeur, c'est à dire:

* on donne à notre fonction un un graph et un noeud de départ
* il retourne une liste de tous les noeuds, parcourus à partir du noeud courant (voir exemple dans le DocTest)

N'hésitez pas à demander de l'aide à votre encadrant et/ou à vous renseigner sur l'algorithme sur internet.

Pour votre code, vous pourriez utiliser:

* l'opérateur `in` qui permet de tester si un élément est dans une liste: `1 in [1, 2, 3, 4]`
* la concaténation de deux listes avec `++`: `[1, 2] ++ [3, 4] == [1, 2, 3, 4]`
* la fonction `Enum.reverse` qui "retourne" une liste

```elixir
defmodule GraphBFS do

  @doc """
    iex> graph = %{ "A" => ["B", "D"], "B" => ["A", "C", "E"], "C" => ["B", "F"], "D" => ["A", "E"], "E" => ["B", "D", "F"], "F" => ["C", "E"] }
    iex> GraphBFS.bfs(graph, "A")
    ["A", "B", "D", "C", "E", "F"]
  """
  def bfs(graph, start) do
    []
  end
  
end
```

```elixir
# CORRECTION POSSIBLE

defmodule GraphBFSCorrige do

  @doc """
    iex> graph = %{ "A" => ["B", "D"], "B" => ["A", "C", "E"], "C" => ["B", "F"], "D" => ["A", "E"], "E" => ["B", "D", "F"], "F" => ["C", "E"] }
    iex> GraphBFSCorrige.bfs(graph, "A")
    ["A", "B", "D", "C", "E", "F"]
  """
  def bfs(graph, start) do
    bfs(graph, [start], [])
  end

  defp bfs(_graph, [], visited), do: Enum.reverse(visited)
  
  defp bfs(graph, [current | rest], visited) do
    dbg(visited)
    if current in visited do
      bfs(graph, rest, visited) # déjà visité
    else
      new_nodes = GraphInfoCorrige.neighbors(graph, current)
      bfs(
        graph, 
        rest ++ new_nodes, # on "enqueue" les noeuds à visiter
        [current | visited] # et on rajoute le noeud visite dans la liste
      )
    end
  end
  
end
```

```elixir
GraphBFSCorrige.bfs(graph, "A")
```

## 3. Plus cours chemin (greedy)

Votre objectif ici est de _reprendre votre code de parcours en largeur_ afin de trouver le plus cours chemin vers un point "objectif":

* on parcours toujours le graphe en largeur
* au lieu de ne stocker que les noeuds, on stocke les noeuds et le chemin qui mène à ce noeud (par ex. dans un tuple)
* quand on arrive à l'objectif on a trouvé le chemin le plus cours (c'est le plus court grâce au parcours en largeur)

À vous de jouer:

```elixir
defmodule GraphShortestPath do

  @doc """
    iex> graph = %{ "A" => ["B", "D"], "B" => ["A", "C", "E"], "C" => ["B", "F"], "D" => ["A", "E"], "E" => ["B", "D", "F"], "F" => ["C", "E"] }
    iex> GraphShortestPath.shortest_path(graph, "A", "C")
    ["A","B","C"]
  """
  def shortest_path(graph, start, goal) do
    []
  end
  
end
```

```elixir
# CORRECTION POSSIBLE

defmodule GraphShortestCorrige do
  @doc """
    iex> graph = %{ "A" => ["B", "D"], "B" => ["A", "C", "E"], "C" => ["B", "F"], "D" => ["A", "E"], "E" => ["B", "D", "F"], "F" => ["C", "E"] }
    iex> GraphShortestCorrige.shortest_path(graph, "A", "C")
    ["A","B","C"]  
  """
  def shortest_path(graph, start, goal) do
    shortest_path(graph, [{start, [start]}], goal, [])
  end

  defp shortest_path(_graph, [], _goal, _visited), do: nil

  defp shortest_path(graph, [{current, path} | rest], goal, visited) do
    dbg(visited)
    cond do
      current == goal ->
        # on a trouvé !
        path

      current in visited ->
        # on skip le noeud
        shortest_path(graph, rest, goal, visited)

      true ->
        new_nodes_with_path =
          GraphInfoCorrige.neighbors(graph, current)
          |> Enum.map(fn n ->
            # on crée les tuples { noeud, chemin }
            {n, path ++ [n]}
          end)

        shortest_path(graph, rest ++ new_nodes_with_path, goal, [current | visited])
    end
  end
end
```

```elixir
data = %{
  id: 1,
  email: "user@example.com",
  inserted_at: ~U[2022-01-01T10:00:00Z],
  addresses: [
    %{
      country: "pl",
      city: "Kraków",
      street: "Karmelicka",
      zip: "00123"
    }
  ]
}

Kino.Tree.new(data)
```
