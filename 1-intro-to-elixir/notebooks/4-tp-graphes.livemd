# C1TP ‚Äì Parcours d‚Äôun graphe et plus court chemin

```elixir
Mix.install([
  {:kino, "~> 0.16.1"},
  {:phoenix_live_view, "~> 1.1"}
])

ExUnit.configure(exclude: [:skip])
ExUnit.start(autorun: false)
```

## Objectif(s)

- Manipuler les **listes** et **maps**.
- Impl√©menter un **algorithme simple** (parcours en largeur ou profondeur).
- D√©couvrir une repr√©sentation **graphique / automate** d‚Äôun probl√®me.
- √âcrire et composer des **fonctions**.

## 1. Repr√©senter un graphe

### Qu‚Äôest-ce qu‚Äôun graphe ?

Un **graphe** $G = (V, E)$ est un couple constitu√© :

- d‚Äôun ensemble $V$ de **sommets** (ou n≈ìuds),
- d‚Äôun ensemble $E \subseteq \{ \{u, v\} \mid u, v \in V, u \ne v \}$ de **paires non ordonn√©es** appel√©es **ar√™tes** (ou liens).

On parle alors de **graphe non orient√©** et **simple** (sans boucles ni ar√™tes multiples).

#### Exemple :

$$
V = \{A, B, C, D\}, \quad E = \{\{A,B\}, \{A,D\}, \{B,C\}, \{C,D\} \}
$$

correspond au graphe suivant:

```mermaid
graph LR
  A --- B
  A --- D
  B --- C
  C --- D
```

<!-- livebook:{"break_markdown":true} -->

### Repr√©sentation informatique du graphe

Il existe beaucoup de mani√®re de repr√©senter un graphe.
On peut le repr√©senter par une **carte** (graphe dessin√©, voir ci-dessous), par un ensemble de "noeuds" dans la m√©moire de l'ordinateur, par une **liste d‚Äôadjacence**, ou encore une **matrice d‚Äôadjacence**.

Dans ce TP, nous utilisons la **liste d‚Äôadjacence**, qui consiste √† associer √† chaque noeud du graphe la liste des noeuds qui le suivent.

Toujous sur notre exemple, cela donnerait:

```elixir
graphe_simple = %{
  "A": [ "B", "D" ], # Les "successeurs de A sont B et D
  "B": [ "C" ],      # Le successeur de B est D
  "C": [ "D" ],      # Le successeur de C est D
}
```

### Un graphe plus complet

On consid√®re un petit comme celui-ci pour repr√©senter notre labyrinthe :

```mermaid
graph LR
  classDef start fill:#dff,stroke:#06c,stroke-width:2px;
  classDef goal  fill:#ffd,stroke:#c60,stroke-width:2px;

  A:::start <--> B <--> C
  A <--> D
  B <--> E
  D <--> E <--> F:::goal
  C <--> F
```

<!-- livebook:{"break_markdown":true} -->

On peut le repr√©senter par une **liste d‚Äôadjacence** :

```elixir
graph = %{
  "A" => ["B", "D"],
  "B" => ["A", "C", "E"],
  "C" => ["B", "F"],
  "D" => ["A", "E"],
  "E" => ["B", "D", "F"],
  "F" => ["C", "E"]
}

%{ "A" => ["B", "D"], "B" => ["A", "C", "E"], "C" => ["B", "F"], "D" => ["A", "E"], "E" => ["B", "D", "F"], "F" => ["C", "E"] }
```

üí° _on remarquera que dans ce cas, le graphe n'est pas "orient√©": s'il est permis d'aller de $A$ vers $B$, alors ils est permis d'aller de $B$ vers $A$_

<!-- livebook:{"break_markdown":true} -->

### √âcrire une fonction `GraphInfo.neighbors/2` qui renvoie la liste des voisins d‚Äôun n≈ìud.

‚ö†Ô∏è Dans le cas o√π aucune arr√™te n'est sp√©cifi√©e pour un noeud, on renverra une liste vide `[]`

üí° Pensez √† consulter la [documentation du module `Map`](https://hexdocs.pm/elixir/Map.html) au besoin

```elixir
defmodule GraphInfo do

  @doc """
    iex> graph = %{ "A" => ["B", "D"], "B" => ["A", "C", "E"] }
    iex> GraphInfo.neighbors(graph, "A")
    ["B", "D"]

    iex> graph = %{ "A" => ["B", "D"], "B" => ["A", "C", "E"] }
    iex> GraphInfo.neighbors(graph, "C")
    []

  """
  def neighbors(graph, node) do
    []
  end

end
```

```elixir
# CORRECTION POSSIBLE

defmodule GraphInfoCorrige do

  @doc """
    iex> graph = %{ "A" => ["B", "D"], "B" => ["A", "C", "E"] }
    iex> GraphInfoCorrige.neighbors(graph, "A")
    ["B", "D"]

    iex> graph = %{ "A" => ["B", "D"], "B" => ["A", "C", "E"] }
    iex> GraphInfo.neighbors(graph, "C")
    []
  """
  def neighbors(graph, node) do
    Map.get(graph, node, [])
  end

end
```

## 2. Parcours en largeur (BFS)

Nous voulons d√©sormais parcourir notre graphe "en largeur, c'est √† dire:

- on donne √† notre fonction un un graph et un noeud de d√©part
- il retourne une liste de tous les noeuds, parcourus √† partir du noeud courant (voir exemple dans le DocTest)

N'h√©sitez pas √† demander de l'aide √† votre encadrant et/ou √† vous renseigner sur [l'algorithme sur internet](https://fr.wikipedia.org/wiki/Algorithme_de_parcours_en_largeur).

Concr√®tement:

- vous devrez maintenir une file des noeuds "√† parcourir": √† chaque noeud visit√© on ajoute ses vions dans les noeuds "√† visiter plus tard"
- une liste des noeuds d√©j√† visit√©s
- et par rapport √† l'algorithme "usuel" vous devrez utiliser la r√©cursion √† la place de l'it√©ration

Pour votre code, vous pourriez utiliser:

- l'op√©rateur `in` qui permet de tester si un √©l√©ment est dans une liste: `1 in [1, 2, 3, 4]`
- la concat√©nation de deux listes avec `++`: `[1, 2] ++ [3, 4] == [1, 2, 3, 4]`
- la fonction `Enum.reverse` qui "retourne" une liste

```elixir
defmodule GraphBFS do

  @doc """
    iex> graph = %{ "A" => ["B", "D"], "B" => ["A", "C", "E"], "C" => ["B", "F"], "D" => ["A", "E"], "E" => ["B", "D", "F"], "F" => ["C", "E"] }
    iex> GraphBFS.bfs(graph, "A")
    ["A", "B", "D", "C", "E", "F"]
  """
  def bfs(graph, start) do
    []
  end

end
```

```elixir
# CORRECTION POSSIBLE

defmodule GraphBFSCorrige do

  @doc """
    iex> graph = %{ "A" => ["B", "D"], "B" => ["A", "C", "E"], "C" => ["B", "F"], "D" => ["A", "E"], "E" => ["B", "D", "F"], "F" => ["C", "E"] }
    iex> GraphBFSCorrige.bfs(graph, "A")
    ["A", "B", "D", "C", "E", "F"]
  """
  def bfs(graph, start) do
    bfs(graph, [start], [])
  end

  defp bfs(_graph, [], visited), do: Enum.reverse(visited)

  defp bfs(graph, [current | rest], visited) do
    if current in visited do
      bfs(graph, rest, visited) # d√©j√† visit√©
    else
      new_nodes = GraphInfoCorrige.neighbors(graph, current)
      bfs(
        graph,
        rest ++ new_nodes, # on "enqueue" les noeuds √† visiter
        [current | visited] # et on rajoute le noeud visite dans la liste
      )
    end
  end

end
```

```elixir
GraphBFSCorrige.bfs(graph, "A")
```

#### Exercice optionnel: r√©-√©crire notre algorithme avec la librairie `:queue`

_**√Ä faire uniquement si vous √™tes tr√®s en avance !**_

Nous pouvons utiliser [la librairie `:queue` d'Erlang](https://www.erlang.org/doc/apps/stdlib/queue.html) pour avoir une structure de donn√©es, plus adapt√©.

De plus, cela va nous permettre d'exp√©rimenter l'inter-op√©rabilit√© entre ce langage ‚Äì qui reste le "socle" d'Elixir ‚Äì et notre progamme √©crit en Elixir. De plus, lire de la documentation technique est toujours une bonne exp√©rience !

<!-- livebook:{"break_markdown":true} -->

Vous pouvez cr√©er une "queue" Erlang en appelant `:queue.new/0` ou `:queue.from_list/1`:

```elixir
queue = :queue.new()
```

```elixir
queue = :queue.from_list([1, 2, 3, 4, 5, 6])
```

Nous remarquons alors plusieurs choses:

- la "queue" est stock√©e dans une structure constitu√©e d'un tuple qui lui-m√™me contient deux listes
- le premier et le dernier √©l√©ment de la notre queue sont les premiers √©l√©ments des deux listes respectives: f_aites varier les √©l√©ments de la queue et vous verrez !

üí° c'est le secret de cette structure, qui maintient une structure permettant d'ajouter et/ou enlever un √©l√©ment au d√©but ou √† la fin de la structure tr√®s rapiement.

<!-- livebook:{"break_markdown":true} -->

La librairie fournit un ensemble de m√©thodes tr√®s simples pour manipuler la queue:

- calculer la taille:

```elixir
:queue.len(queue)
```

- ajouter un √©l√©ment:
  - au d√©but avec `:queue.in/1` pour ins√©rer **√† la fin** de la liste
  - √† la fin avec `:queue.in_r/2` pour ins√©rer **au d√©but** de la liste

```elixir
queue = :queue.in(7, queue) # ajoute √† la fin (premi√®re liste du tuple)
```

```elixir
 queue = :queue.in_r(0, queue) # ajoute au d√©but (seconde liste du tuple)
```

- pour enlever un √©l√©ment, nous pouvons utiliser:

  - `:queue.get/1` pour lire **au d√©but** de la liste
  - `:queue.get_r/1` pour lire **√† la fin** de la liste
  - `:queue.out/1` pour lire **au d√©but** de la liste \_et retourner la liste sans cet √©l√©ment
  - `:queue.out_r/1` pour lire **√† la fi** de la liste \_et retourner la liste sans cet √©l√©ment

  ‚ö†Ô∏è le `_r` ne signifie pas "devant" our "derri√®re" mais signifie que c'est _l'inverse_ du `in_r`:

  - avec `in` et `out` (ou `get`) on a une FIFO o√π l'on ins√®re √† la fin et on lit au d√©but
  - avec `in_r` et `out_r` (ou `get_r`) on a une FIFO o√π l'on ins√®re au d√©but et on lit √† la fin
  - avec `in` et `out_r` (ou `get_r`) on a une LIFO o√π l'on ins√®re √† la fin et on lit √† la fin
  - avec `in_r` et `out` (ou `get`) on a une LIFO o√π l'on ins√®re au d√©but et on lit au d√©but

```elixir
# lecture au d√©but
IO.inspect :queue.get(queue), label: "Valeur du d√©but"

# lecture √† la fin
IO.inspect :queue.get_r(queue), label: "Valeur finale"
```

üí° Attention, `get` et `get_r` vont lever une erreur si la liste est vide:

<!-- livebook:{"continue_on_error":true} -->

```elixir
queue_vide = :queue.new()
:queue.get(queue_vide)
```

- une meilleur option sera d'utiliser `out` et `out_r`:
  - si la queue n'est pas vide, la valeur de retour sera un tuple:
    `{ {:value, valeur }, queue_sans_cette_valeur }`
  - si la queue est vide, la valeur de retour sera: `{ :empty, queue }`

```elixir
# on r√©cup√®re la valeur au d√©but de la liste et on l'enl√®ve de la liste
{{ :value, value }, queue } = :queue.out(queue)
IO.inspect value, label: "Valeur extraite (premi√®re valeur)"

# pour afficher notre liste modifi√©e, nous pouvons la convertir en liste:
:queue.to_list(queue)
```

```elixir
# on r√©cup√®re la valeur finale de la liste et on l'enl√®ve de la liste
{{ :value, value }, queue } = :queue.out_r(queue)
IO.inspect value, label: "Valeur extraite (derni√®re valeur)"

# pour afficher notre liste modifi√©e, nous pouvons la convertir en liste:
:queue.to_list(queue)
```

√Ä vous de jouer:

```elixir
defmodule GraphBFSQueue do

  @doc """
    iex> graph = %{ "A" => ["B", "D"], "B" => ["A", "C", "E"], "C" => ["B", "F"], "D" => ["A", "E"], "E" => ["B", "D", "F"], "F" => ["C", "E"] }
    iex> GraphBFSQueue.bfs(graph, "A")
    ["A", "B", "D", "C", "E", "F"]
  """
  def bfs(graph, start) do
    []
  end

end
```

```elixir
# CORRECTION POSSIBLE

defmodule GraphBFSQueueCorrige do

  @doc """
    iex> graph = %{ "A" => ["B", "D"], "B" => ["A", "C", "E"], "C" => ["B", "F"], "D" => ["A", "E"], "E" => ["B", "D", "F"], "F" => ["C", "E"] }
    iex> GraphBFSQueueCorrige.bfs(graph, "A")
    ["A", "B", "D", "C", "E", "F"]
  """
  def bfs(graph, start) do
    bfs(graph, :queue.from_list([start]), [])
  end

  defp bfs(_graph, {[], []}, visited), do: Enum.reverse(visited)

  defp bfs(graph, queue, visited) do
    {{:value, current}, rest} = :queue.out(queue)
    if current in visited do
      bfs(graph, rest, visited) # d√©j√† visit√©
    else
      new_nodes = GraphInfoCorrige.neighbors(graph, current)
      bfs(
        graph,
        :queue.join(rest, :queue.from_list(new_nodes)),
        [current | visited] # et on rajoute le noeud visite dans la liste
      )
    end
  end

end
```

## 3. Plus cours chemin (Dijkstra-like)

Votre objectif ici est de _reprendre votre code de parcours en largeur_ afin de trouver le plus cours chemin vers un point "objectif".

M√™me si √ßa peut para√Ætre compliqu√©, nous avons toutes les briques n√©cessaires pour r√©aliser ce calcul.

- jusqu'√† maintenant, nous construisions une liste de "noeuds visit√©s" que nous retournions √† la fin de l'algorithme
- vous allez faire √©voluer cette liste vers une liste de tuple `{ "Noeud", [ "Chemin", "vers", "ce", "noeud" ] }`
- d√®s que atteindra le noeud objectif, on retournera le chemin vers ce noeud

_encore une fois, n'h√©sitez pas √† solliciter l'aide de votre professeur !_

√Ä vous de jouer:

```elixir
defmodule GraphShortestPath do

  @doc """
    iex> graph = %{ "A" => ["B", "D"], "B" => ["A", "C", "E"], "C" => ["B", "F"], "D" => ["A", "E"], "E" => ["B", "D", "F"], "F" => ["C", "E"] }
    iex> GraphShortestPath.shortest_path(graph, "A", "C")
    ["A","B","C"]
  """
  def shortest_path(graph, start, goal) do
    []
  end

end
```

```elixir
# CORRECTION POSSIBLE

defmodule GraphShortestCorrige do
  @doc """
    iex> graph = %{ "A" => ["B", "D"], "B" => ["A", "C", "E"], "C" => ["B", "F"], "D" => ["A", "E"], "E" => ["B", "D", "F"], "F" => ["C", "E"] }
    iex> GraphShortestCorrige.shortest_path(graph, "A", "C")
    ["A","B","C"]
  """
  def shortest_path(graph, start, goal) do
    shortest_path(graph, [{start, [start]}], goal, [])
  end

  defp shortest_path(_graph, [], _goal, _visited), do: nil

  defp shortest_path(graph, [{current, path} | rest], goal, visited) do
    dbg(visited)
    cond do
      current == goal ->
        # on a trouv√© !
        path

      current in visited ->
        # on skip le noeud
        shortest_path(graph, rest, goal, visited)

      true ->
        new_nodes_with_path =
          GraphInfoCorrige.neighbors(graph, current)
          |> Enum.map(fn n ->
            # on cr√©e les tuples { noeud, chemin }
            {n, path ++ [n]}
          end)

        shortest_path(graph, rest ++ new_nodes_with_path, goal, [current | visited])
    end
  end
end
```
