# C1TP ‚Äì Parcours d‚Äôun graphe et plus court chemin

```elixir
Mix.install([
  {:kino, "~> 0.16.1"},
  {:phoenix_live_view, "~> 1.1"}
])

ExUnit.configure(exclude: [:skip])
ExUnit.start(autorun: false)
```

## Objectif(s)

* Manipuler les **listes** et **maps**.
* Impl√©menter un **algorithme simple** (parcours en largeur ou profondeur).
* D√©couvrir une repr√©sentation **graphique / automate** d‚Äôun probl√®me.
* √âcrire et composer des **fonctions**.

## 1. Repr√©senter un graphe

### Qu‚Äôest-ce qu‚Äôun graphe ?

Un **graphe** $G = (V, E)$ est un couple constitu√© :

* d‚Äôun ensemble $V$ de **sommets** (ou n≈ìuds),
* d‚Äôun ensemble $E \subseteq \{ \{u, v\} \mid u, v \in V, u \ne v \}$ de **paires non ordonn√©es** appel√©es **ar√™tes** (ou liens).

On parle alors de **graphe non orient√©** et **simple** (sans boucles ni ar√™tes multiples).

#### Exemple :

$$
V = \{A, B, C, D\}, \quad E = \{\{A,B\}, \{A,D\}, \{B,C\}, \{C,D\} \}
$$

correspond au graphe suivant:

```mermaid
graph LR
  A --- B
  A --- D
  B --- C
  C --- D
```

<!-- livebook:{"break_markdown":true} -->

### Repr√©sentation informatique du graphe

Il existe beaucoup de mani√®re de repr√©senter un graphe.
On peut le repr√©senter par une **carte** (graphe dessin√©, voir ci-dessous), par un ensemble de "noeuds" dans la m√©moire de l'ordinateur, par une **liste d‚Äôadjacence**, ou encore une **matrice d‚Äôadjacence**.

Dans ce TP, nous utilisons la **liste d‚Äôadjacence**, qui consiste √† associer √† chaque noeud du graphe la liste des noeuds qui le suivent.

Toujous sur notre exemple, cela donnerait:

```elixir
graphe_simple = %{
  "A": [ "B", "D" ], # Les "successeurs de A sont B et D
  "B": [ "C" ],      # Le successeur de B est D
  "C": [ "D" ],      # Le successeur de C est D
}
```

### Un graphe plus complet

On consid√®re un petit comme celui-ci pour repr√©senter notre labyrinthe :

```mermaid
graph LR
  classDef start fill:#dff,stroke:#06c,stroke-width:2px;
  classDef goal  fill:#ffd,stroke:#c60,stroke-width:2px;

  A:::start <--> B <--> C
  A <--> D
  B <--> E
  D <--> E <--> F:::goal
  C <--> F
```

<!-- livebook:{"break_markdown":true} -->

On peut le repr√©senter par une **liste d‚Äôadjacence** :

```elixir
graph = %{
  "A" => ["B", "D"],
  "B" => ["A", "C", "E"],
  "C" => ["B", "F"],
  "D" => ["A", "E"],
  "E" => ["B", "D", "F"],
  "F" => ["C", "E"]
}

%{ "A" => ["B", "D"], "B" => ["A", "C", "E"], "C" => ["B", "F"], "D" => ["A", "E"], "E" => ["B", "D", "F"], "F" => ["C", "E"] }
```

üí° _on remarquera que dans ce cas, le graphe n'est pas "orient√©": s'il est permis d'aller de $A$ vers $B$, alors ils est permis d'aller de $B$ vers $A$_

<!-- livebook:{"break_markdown":true} -->

### √âcrire une fonction `GraphInfo.neighbors/2` qui renvoie la liste des voisins d‚Äôun n≈ìud.

‚ö†Ô∏è Dans le cas o√π aucune arr√™te n'est sp√©cifi√©e pour un noeud, on renverra une liste vide `[]`

üí° Pensez √† consulter la [documentation du module `Map`](https://hexdocs.pm/elixir/Map.html) au besoin

```elixir
defmodule GraphInfo do

  @doc """
    iex> graph = %{ "A" => ["B", "D"], "B" => ["A", "C", "E"] }
    iex> GraphInfo.neighbors(graph, "A")
    ["B", "D"]

    iex> graph = %{ "A" => ["B", "D"], "B" => ["A", "C", "E"] }
    iex> GraphInfo.neighbors(graph, "C")
    []

  """
  def neighbors(graph, node) do
    []
  end

end
```

```elixir
# CORRECTION POSSIBLE

defmodule GraphInfoCorrige do

  @doc """
    iex> graph = %{ "A" => ["B", "D"], "B" => ["A", "C", "E"] }
    iex> GraphInfoCorrige.neighbors(graph, "A")
    ["B", "D"]

    iex> graph = %{ "A" => ["B", "D"], "B" => ["A", "C", "E"] }
    iex> GraphInfo.neighbors(graph, "C")
    []
  """
  def neighbors(graph, node) do
    Map.get(graph, node, [])
  end

end
```

## 2. Parcours en largeur (BFS)

Nous voulons d√©sormais parcourir notre graphe "en largeur, c'est √† dire:

* on donne √† notre fonction un un graph et un noeud de d√©part
* il retourne une liste de tous les noeuds, parcourus √† partir du noeud courant (voir exemple dans le DocTest)

N'h√©sitez pas √† demander de l'aide √† votre encadrant et/ou √† vous renseigner sur [l'algorithme sur internet](https://fr.wikipedia.org/wiki/Algorithme_de_parcours_en_largeur).

Concr√®tement:

* vous devrez maintenir une file des noeuds "√† parcourir": √† chaque noeud visit√© on ajoute ses vions dans les noeuds "√† visiter plus tard"
* une liste des noeuds d√©j√† visit√©s
* et par rapport √† l'algorithme "usuel" vous devrez utiliser la r√©cursion √† la place de l'it√©ration

Pour votre code, vous pourriez utiliser:

* l'op√©rateur `in` qui permet de tester si un √©l√©ment est dans une liste: `1 in [1, 2, 3, 4]`
* la concat√©nation de deux listes avec `++`: `[1, 2] ++ [3, 4] == [1, 2, 3, 4]`
* la fonction `Enum.reverse` qui "retourne" une liste

<!-- livebook:{"continue_on_error":true} -->

```elixir
defmodule GraphBFS do

  @doc """
    iex> graph = %{ "A" => ["B", "D"], "B" => ["A", "C", "E"], "C" => ["B", "F"], "D" => ["A", "E"], "E" => ["B", "D", "F"], "F" => ["C", "E"] }
    iex> GraphBFS.bfs(graph, "A")
    ["A", "B", "D", "C", "E", "F"]
  """
  def bfs(graph, start) do
    []
  end

end
```

```elixir
GraphBFS.bfs(graph, "A")
```

## 3. Plus cours chemin (Dijkstra-like)

Votre objectif ici est de _reprendre votre code de parcours en largeur_ afin de trouver le plus cours chemin vers un point "objectif".

M√™me si √ßa peut para√Ætre compliqu√©, nous avons toutes les briques n√©cessaires pour r√©aliser ce calcul.

* jusqu'√† maintenant, nous construisions une liste de "noeuds visit√©s" que nous retournions √† la fin de l'algorithme
* vous allez faire √©voluer cette liste vers une liste de tuple `{ "Noeud", [ "Chemin", "vers", "ce", "noeud" ] }`
* d√®s que atteindra le noeud objectif, on retournera le chemin vers ce noeud

_encore une fois, n'h√©sitez pas √† solliciter l'aide de votre professeur !_

√Ä vous de jouer:

```elixir
defmodule GraphShortestPath do

  @doc """
    iex> graph = %{ "A" => ["B", "D"], "B" => ["A", "C", "E"], "C" => ["B", "F"], "D" => ["A", "E"], "E" => ["B", "D", "F"], "F" => ["C", "E"] }
    iex> GraphShortestPath.shortest_path(graph, "A", "C")
    ["A","B","C"]
  """
  def shortest_path(graph, start, goal) do
    []
  end

end
```

üí° Commencez par recopier le code de la version pr√©c√©dente, que vous pourrez "enrichir" au fur et √† mesure !
