<!-- livebook:{"file_entries":[{"name":"pattern-match-case.png","type":"attachment"},{"name":"terminal-rec-ok-ko.png","type":"attachment"}]} -->

# C1N3 ‚Äì Approfondissement sur les fonctions

```elixir
Mix.install([
  {:pythonx, "~> 0.4.2"},
  {:kino_pythonx, "~> 0.1.0"},
  {:kino, "~> 0.16.1"}
])
```

```pyproject.toml
[project]
name = "project"
version = "0.0.0"
requires-python = "==3.13.*"
dependencies = []
```

## Les fonctions et le pattern-matching

Jusqu'√† pr√©sent, nous avons explor√© les fonctions a travers des cas simples, en respectant toujours une m√™me syntaxe:

- la fonction est d√©finie une fois par module
- elle prend (en option) des arguments sous forme de variable
- son bloc, d√©fini entre les d√©limiteurs `do`...`end`, retourne sa derni√®re valeur

<!-- livebook:{"break_markdown":true} -->

Cette fa√ßon de faire fonctionne tr√®s bien, et permet de traiter des cas relativement complexes:

```elixir
defmodule Factorielle do

  def fact(n) do
    case n do
      0 ->
        1

      n ->
        n * fact(n-1)
    end
  end

end

Factorielle.fact(4)
```

Le code ci-dessous, bien que parfaitement valide, n'est pas parfaitement idiomatique, ce cela pour plusieurs raison. Dans les _sections ci-dessous_, nous allons explorer de nouveaux √©l√©ments de syntaxe qui vont nous permettre de simplifier ce code, √©tape par √©tape.

<!-- livebook:{"break_markdown":true} -->

#### √âl√©ment de syntaxe n¬∞1 : le pattern matching dans la d√©claration de la fonction

Le code ci-dessus, via son `case`, r√©alise une op√©ration de "pattern matching" : c'est-√†-dire qu'il tente de faire correspondre la variable `n` avec une s√©rie de valeur successive (d'abord `0`, puis une valeur quelconque) afin de trouver une correspondance:

![](files/pattern-match-case.png)

Il est en fait possible de **r√©aliser cette op√©ration** directement au niveau de la d√©claration de la fonction, comme suit:

```elixir
defmodule FactorielleV2 do

  def fact(0) do
    1
  end

  def fact(n) do
     n * fact(n-1)
  end

end

FactorielleV2.fact(4)
```

ici nous avons apport√© deux modifications:

1. nous avons √©crit deux fois la m√™me fonction
2. dans la permi√®re "version" de la fonction nous avons remplac√© la variable `n` par la valeur constante `0`

Suite √† cette modification, Elixir va d√©sormer √©valuer `FactorielleV2.fact/1` comme suit:

- il va "tester" les diff√©rentes variantes de la fonction, **dans l'ordre o√π elle sont d√©finies** ("de haut en bas" dans le code) et ex√©cuter _la premi√®re fonction pour laquelle les argument "matchent" la valeur pass√©e en argument_
- dans le cas d'une r√©cursion ‚Äì cf. ligne 8 ci-dessus - il re-testera toutes les fonctions dans l'ordre

‚ö†Ô∏è **ATTENTION**: ce mode de fonctionnement, o√π Elixir teste nos fonctions jusqu'√† en trouver une qui convienne implique plusieurs comportements:

- si nous avions plac√© la variante `fact(n)` _au dessus_ de `fact(0)`, cette derni√®re _ne serait jamais appel√©e_: car `fact(n)` "branche toujours", `n` √©tant une variable libre qui accepte n'importe quelle valeur !
- si _aucune des variantes_ d'une fonction ne "branche", Elixir g√©n√®rera une erreur et le programme s'arr√™te

<!-- livebook:{"break_markdown":true} -->

#### √âl√©ment de syntaxe #2 : blocs d'une ligne

Quand le bloc ne contient qu'une expression simple, il est possible de _l'abr√©ger_:

- on remplace `do`...`end` par un argument `do:`
- et on place une virgule `,` avant ce `do:`

d√©monstration:

```elixir
defmodule FactorielleV3 do

  # le bloc do...end a disparu au profix de , do: ...
  #         üëá attention √† ne pas oublier cette virgule !
  def fact(0), do: 1

  #         üëá ni celle-l√† !
  def fact(n), do: n * fact(n-1)

end

FactorielleV3.fact(4)
```

## La r√©cursivit√© terminale

Elixir ‚Äì¬†comme OCaml... mais pas comme Python ‚Äì est capable d'optimiser les fonctions r√©cursives qui ont la propri√©t√© de _r√©cursivit√© terminale_, c'est-√†-dire:

- ce sont des fonctions r√©cursives
- la derni√®re op√©rations qu'elles r√©alisent est _soit_:
  - le renvoi d'une valeur constante
  - un appel r√©cursif √† elles-m√™me

<!-- livebook:{"break_markdown":true} -->

**Question**: nos questions ci-dessus (par ex. `FactorielleV3.fact/1`) ont-elles cette propri√©t√© de _r√©cusrivit√© terminale_ ?

_(r√©fl√©chissez un peu avant de scoller pour voir la r√©ponse üòâ)_

<div style="height: 100vh">

</div>

<!-- livebook:{"break_markdown":true} -->

Et bien la r√©ponse est **NON** !

en effet, la derni√®re op√©ration de notre fonction `fact()` n'est pas de s'appeler elle-m√™me, c'est la **multiplication**:

![](files/terminal-rec-ok-ko.png)

<!-- livebook:{"break_markdown":true} -->

Nous allons r√©-√©crire notre calcul de la factorielle pour utiliser cette r√©cursivit√© terminale.

Mais avant √ßa pr√©sentons un dernier √©l√©ment de syntaxe:

<!-- livebook:{"break_markdown":true} -->

#### √âl√©ment de syntaxe #3 : les fonctions _priv√©es_

En rempla√ßant `def` par `defp` lors de la d√©claration de fonctions dans nos modules, il est possible de cr√©er des fonctions priv√©es:

- elle sont appelables par les autres fonctions dans le m√™me modules
- mais ne sont pas accessible en dehors du module

D√©monstration:

<!-- livebook:{"continue_on_error":true} -->

```elixir
defmodule PublicPrivateDemo do

  def public_f do
    IO.puts("Je suis une fonction publique")
    private_f()
  end

  #  üëá c'est le "p" de "defp" qui marque la fonction comme priv√©e
  defp private_f do
    IO.puts("Je suis une fonction priv√©e")
  end

end

# ‚úÖ cet appel va fonctionner, et la fonction priv√©e sera invoqu√©e
PublicPrivateDemo.public_f()

# üõë l'appel suivant ne fonctionnera pas
PublicPrivateDemo.private_f()
```

### Version "terminal recusrive" de la factorielle

Pour optimiser notre fonction factorielle, nous allons apporter deux modifications √† notre code:

- la fonction `fact/1` d√©l√®guera le calcul √† une fonction priv√©e `fact/2`
- cette derni√®re sera rendue terminal-recusrive en _rajoutant un argument "accumulateur"_

en pratique:

```elixir
defmodule FactorielleV4 do

  # Notre seule fonction "publique" d√©l√®gue √† la fonction priv√©e
  def fact(n), do: fact(n, 1)

  # √Ä la fin de la r√©cursion, on retourne l'accumulateur (second arg)
  defp fact(0, acc), do: acc

  #                            üëá le d√©cr√©ment du compteur
  defp fact(n, acc), do: fact(n-1, n * acc)
  #                      ‚Üë           üëÜ le produit du calcul
  #                      ‚îî on appelle "fact" en dernier !

end

FactorielleV4.fact(4)
```

## Exercice pratique

√âcrivez un module simple qui calcule le ni√®me terme de la [suite de Fibonacci](https://fr.wikipedia.org/wiki/Suite_de_Fibonacci).

Pour rappel, la suite est d√©finit comme suit:

$$
\begin{aligned}
F_{0} & =0 \\
F_{1} & =1 \\
F_{n+2} & = F_{n+1}+F_n
\end{aligned}
$$

Vous pouvez faire plusieurs variantes:

```elixir
defmodule TP3Exercice1 do

  @doc """
  Calcule le n-i√®me terme de la suite de Fibonacci

  ## Exemple

    iex> TP3Exercice1.fib(2)
    1

    iex> TP3Exercice1.fib(3)
    2

    iex> TP3Exercice1.fib(10)
    55
  """
  def fib(b) do
    0 # TODO
  end

end
```

## L'op√©rateur "pipe"

Il est souvent n√©cessaire d'encha√Æner les appels de fonctions les une apr√®s les autres, afin d'apporter des modifications successives √† une donn√©e de d√©part.

Prenons un exemple pratique : imaginons que nous travaillions sur un syst√®me de blog. L'utilisateur peut cr√©er des articles, et d√©finir le titre du nouvel article. Puis arrive le moment de la publication et nous souhaiterions g√©n√©rer une adresse "explicite" pour ce post, par ex:

- si l'utilisateur a √©crit un post nomm√© "Mon premier blog-post"
- nous aimerions que l'adresse internet de l'article soit "mon-premier-blog-post"

Pour se faire, nous imaginons un algorithme:

- nous partons du titre et le mettons en minuscue
- puis nous s√©parons les mots en "coupant" au niveau des espaces
- enfin nous "regroupons" les morceaux en les relitant avec des tirets `-`

En Python:

```python
titre_article = "Mon premier blog post"

    # la m√©thode .join() de ste
"-".join(
  titre_article
    .lower()    # transforme la str en minuscule
    .split(" ") # coupe la str en une list de str
)
```

Essayons maintenant de faire la m√™me chose en Elixir:

```elixir
titre_article = "Mon premier blog post"

Enum.join(
  String.split(
    String.downcase(
      titre_article
    ),
    " "
  ),
  "-"
)
```

ce n'est pas extr√™mement lisible...

Une alternative possible serait de passer par une variable que l'on r√©-assignerait au fur et √† mesure des transformations:

```elixir
titre_article = "Mon premier blog post"

slug = String.downcase(titre_article)
slug = String.split(slug, " ")
slug = Enum.join(slug, "-")
slug
```

Beaucoup mieux !

Nous voyons l√† les forces et les faiblesse de l'approche "objet" de Python:

- il est facile "d'encha√Æner" les appels des _m√©thodes_ de `str` telles que `.lower()` et `.split()`
- la "cha√Æne de caract√®re courante" est pass√©e implicitement : le langage "sait" que nous travaillons sur `titre_article`
- par contre, √ßa ne fonctionne pas lorsque la fonction √† appeler ne fait pas partie des m√©thodes de `str` : dans le code Python plus haut, nous avons finalement besoin de faire un `.join()` mais cette m√©thode n'est pas disponible, et on ne peut pas "encha√Æner l'appel avec `.`"

Elixir propose **une syntaxe dite de "pipe" `|>`** qui permet de faire sensiblement la m√™me chose:

- le r√©sultat de la fonction pr√©c√©dente est implicitement pass√© comme premier argument de la fonction suivante
- on peut mettre n'importe quelle fonctions "√† la suite", contrairement aux objets ou seules mes _m√©thodes de la classe_ peuvent √™tre "cha√Æn√©es"

D√©monstration:

```elixir
titre_article = "Mon premier Blog Post"

titre_article
|> String.downcase()  # titre_article est pass√© en argument implicitement
|> String.split(" ")  # idem pour le r√©sultat de downcase
|> Enum.join("-")     # et de join
```

**BONUS**: debug des encha√Ænements d'op√©rations

Elixir dispose d'une macro `dbg` qui permet d'analyser ce qui se passe √† l'int√©rieur d'une suite d'op√©rations. Cette fonctionnalit√© est particuli√®rement bien int√©gr√©e √† LiveBook.

Pour l'utiliser il suffit de _rajouter une √©tape de pipe vers `dbg()`_:

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
titre_article
|> String.downcase()
|> String.split(" ")
|> Enum.join("-")
|> dbg()
```

## Les fonctions anonymes

Elixir dispose d'un √©quivalent aux `lambda`s de Python: c'est-√†-dire une fa√ßon de d√©finir une fonction qui n'a pas de nom (et qui _n'appartient pas √† un module_ !).

Cette syntaxe se pr√©sente comme suit:

- le mot-cl√© `fn`
- suivi (√©ventuellement), d'une liste d'arguments
- suivi d'une "fl√®che" `->`
- et enfin le mot-cl√© `end` √† la fin de la d√©claration

```elixir
# Exemple de fonction, mise dans la variable ma_f
elixir_anon_f = fn x ->
  x+1
end
```

est √©quivalent √† la d√©claration Python:

```python
python_anon_f = lambda x: x+1
```

on peut v√©rifier que cette variable contient bien une fonction:

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
is_function(elixir_anon_f)
```

et on peut l'**invoquer**.

‚ö†Ô∏è **ATTENTION** quand on √©voque une fonction anonyme, il faut rajouter un `.` avant les parenth√®ses !

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
elixir_anon_f.(10)
```

### Quel est l'int√©r√™t de ces fonctions anonymes ?

Les fonctions anonymes sont utiles en tant qu'argument pass√© √† d'autres fonctions, dans l'objectif de sp√©cialiser un comportement.

Par exemple, on pourrait vouloir effectuer une op√©ration "en s√©rie" sur tous les √©l√©ments d'une liste, comme le ferait `map` en Python:

```python
l = [1, 2, 3, 4]

list(
  map(
    lambda x: x ** 3, # on applique cette fonction "cube"
    l # √† tous les √©l√©ments de l
  )
)
```

Pour r√©aliser la m√™me chose en Elixir, on ira piocher dans les resources du [module `Enum` d'Elixir](https://hexdocs.pm/elixir/Enum.html) qui permet de travailler sur les collections (et les listes en particulier):

```elixir
l = [1, 2, 3, 4]

l
|> Enum.map(fn x -> x ** 3 end)
```

#### Un petit exercice

Le but de cet exercice est avant tout de vous familiariser avec [la documentation d'`Enum`](https://hexdocs.pm/elixir/Enum.html) en recherchant un moyen de r√©aliser un petit exemple simple:

- on vous donne les liste des couleurs et des valeurs des cartes √† jouer classiques (en anglais, car en fran√ßais "Roi" et "Reine" commencent par la m√™me lettre...)
- vous devez g√©n√©rer la liste de toutes cartes possbiles en combinant ces deux listes

par ex.: ‚ô†Ô∏èA pour l'as de pique, ‚ô•Ô∏è9 pour le neuf de coeur etc.

```elixir
couleurs = ["‚ô†Ô∏è", "‚ô•Ô∏è", "‚ô¶Ô∏è", "‚ô£Ô∏è"]
valeurs = ["A", "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K"]

# √Ä vous de jouer !
```

#### Le probl√®me de "la boucle `for`"

Elixir ne poss√®de pas de boucle `for` comme en Python.
Il y a des raisons √† cela, et en particulier la m√©moire "immutable" ne permet pas certains constructions.

Il y a alors deux fa√ßons d'it√©rer une s√©rie de valeurs:

- utiliser la _r√©cursion_: √ßa ne vous para√Æt sans doute pas (encore) naturel mais c'est tr√®s commun
- utiliser le module `Enum` et en particulier [la fonction `Enum.each/2`](https://hexdocs.pm/elixir/Enum.html#each/2)

Par exemple:

```elixir
l = [ 1, 2, 3, 4, 5 ]

# Parcourons les valeurs pour √©crire dans la console:
l
|> Enum.with_index()
|> Enum.each(fn {x, index} ->
  IO.puts("la valeur n¬∞#{index+1} = #{x}")
end)
# |> dbg()
```

## Les compr√©hensions de liste

Je vous ai expliqu√© qu'au paragraphe pr√©c√©dent qu'Elixir n'avait pas de boucle `for`: c'est √† la fois vrai et faux üòÖ

Si l'on veut √™tre pr√©cis, Elixir n'a pas de "boucle `for`" mais une "macro `for`" et cette fonctionnalit√© est appel√©e "compr√©hension" en Elixir. Ce nom n'est pas choisi au hasard: son utilisation est tr√®s proche des _compr√©hensions de listes_ Python.

Illustration: _ex√©cutez la cellulle ci-dessous_ üëá

```elixir
for i <- [1, 2, 3, 4] do
  i ** 2
end
```

d'un point de vue syntaxique, la compr√©hension de liste Elixir se construit comme suit:

- le mot-cl√© `for`
- suivi d'une assignation de variable, sous la forme `nom_de_variable <- collection`
- et d'un bloc `do`...`end`

Cette _expression_ retourne finalement une _nouvelle liste_ o√π chaque √©l√©ment est le r√©sultat du bloc qui est ex√©cut√©.

bien entendu, la collection peut aussi venir d'une variable: par exemple les `couleurs` de cartes d√©finies dans la section pr√©c√©dente:

```elixir
for c <- couleurs do
  "#{c}!"
end
```

mais bien entendu, les capacit√©s du `for` Elixir ne s'arr√™tent pas l√† !

### It√©ration de liste en parall√®le

Le `for` d'Elixir permet tr√®s facilement d'it√©rer plusieurs listes "en m√™me temps", par exemple:

```elixir
for c <- couleurs,
    v <- valeurs do
  c <> v
end
```

nous avons r√©solu l'exercice pr√©c√©dent en trois lignes !

on pourrait m√™me √©crire une version encore plus courte, en rempla√ßant le bloc `do`...`end` par sa forme abr√©g√©e `, do: ...`:

```elixir
all_cards = for c <- couleurs, v <- valeurs, do: c <> v
```

on peut v√©rifier au passage qu'on a bien 52 cartes:

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
length(all_cards)
```

### Filtrage de donn√©es

Il est √©galement possible d'intercaler des "tests" dans notre expression `for`, afin de filtrer certaines valeurs.

Par exemple on pourrait vouloir un jeu de 32 cartes, c'est-√†-dire un jeu sans les cartes de 2 √† 6:

```elixir
less_cards =
  for c <- couleurs,
      v <- valeurs,
      # üëá je rejette les cas o√π v est cette la liste
      v not in ~w[2 3 4 5 6] do
    c <> v
  end
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
length(less_cards)
```

Nous n'avons fait qu'√©ffleurer la surface de ce qui est possible avec les compr√©hensions Elixir. Pour aller plus loin, vous pouvez consulter:

- la [documentation d'Elixir sur le `for`](https://hexdocs.pm/elixir/Kernel.SpecialForms.html#for/1)
- l'[article de Mitchell Hanberg](https://www.mitchellhanberg.com/the-comprehensive-guide-to-elixirs-for-comprehension/) sur le sujet

<!-- livebook:{"break_markdown":true} -->

---

Nous avons termin√© nous tour des principaux √©l√©ments de syntaxe d'Elixir.

Vous √™tes d√©sormais fin pr√™ts √† aborder le [TP final](4-tp-graphes.livemd).
